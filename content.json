{"meta":{"title":"厽乂彐","subtitle":"记录生活中的点点滴滴","description":"直到这一刻微笑着说话为止，我至少留下了一公升眼泪","author":"张磊","url":"http://laxe.top","root":"/"},"pages":[],"posts":[{"title":"Vue-Cli","slug":"Vue-Cli","date":"2019-10-21T02:58:45.235Z","updated":"2019-10-21T02:59:48.462Z","comments":true,"path":"2019/10/21/Vue-Cli/","link":"","permalink":"http://laxe.top/2019/10/21/Vue-Cli/","excerpt":"组件开发自动化工具 Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言 运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上 功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。","text":"组件开发自动化工具 Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言 运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上 功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。 Node.js如果安装成功，可以查看Node.js的版本,在终端输入如下命令 12node -vnpm 全局安装vue脚手架，vue-cli，这玩意儿可以自动生成项目模板 12vue-clicnpm install --global vue-cli 单页应用 SPWA 单页Web应用（single page web application，SPWA），就是将系统所有的操作交互限定在一个web页面中。 单页应用程序 (SPA)是加载单个HTML页面，系统的不同功能通过加载不同功能组件的形式来切换，不同功能组件全部封装到了js文件中，这些文件在应用开始访问时就一起加载完； 整个系统在切换不同功能时，页面的地址是不变的，系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验 通过vue-cli脚手架开启一个项目： 1234567891011121314151617181920212223242526272829vue init webpack myproject- Project name: 项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。- Project description: 项目描述，直接回车- Author：作者- vue build: 构建方式 默认即可- install vue-router? 是否安装vue的路由插件- Use ESLint to lint your code? 是否使用ESLint检测你的代码？ （ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。） - Pick an ESLint preset:选择分支风格 1.standard(https://github.com/feross/standard) js的标准风格 2.Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github 地址说是JavaScript最合理的方法 3.none (configure it yourself) 自己配置 - Setup unit tests? 是否安装单元测试- Pick a test runner 选择一个单元测试运行器 1.Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架） 2.Karma and Mocha 3.none - Setup e2e tests with Nightwatch(Y/n)?是否安装E2E测试框架NightWatch （E2E，也就是End To End，就是所谓的“用户真实场景”。） - Should we run 'npm install' for you after the project has been created?项目创建后是否要为你运行“npm install”? yes,use npm(使用npm) yes,use yarn(使用yarn) no,I will handle that myself(自己操作) 启动开发服务器： 123cd myproject # 进入目录cnpm install # 安装依赖cnpm run dev # 开启服务 vue启动服务之后，是通过一个小型的express服务进行测试开发环境部署，在这个服务中，主要是通过webpack-dev-middleware和webpack-hot-middleware这两个中间件完成，并且会在每次代码对于src目录下的代码进行修改时，服务端会动态检测并让浏览器自动刷新 项目目录介绍 123456- src # 主开发目录，所有的单文件组件都会放在这个目录下- static # 项目静态目录，所有的css、js都会放在这个文件夹下- dist # 项目打包发布文件夹，最后要上线单文件夹项目都在这个文件夹中- node_modules # node的包目录- config # 配置目录，主要用于区分开发环境，测试环境，线上环境的不同- build # 项目打包时依赖的目录 组件开发 将一个组件相关的html结构，css样式，以及交互的JavaScript代码从html文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为.vue，比如：menu.vue 组件文件一般定义在src目录下的components文件夹里 template标签定义HTML部分 12345678&lt;teamplate&gt; &lt;div class=\"\" @click=\"\"&gt; &lt;label&gt; 账号 &lt;input type=\"text\"&gt; &lt;/label&gt; &lt;/div&gt;&lt;/teamplate&gt; js写成模块导出的形式 123456789// 使用export default命令，为模块指定默认输出export default&#123; data: function()&#123; return &#123; name:\"张三\", age:16, &#125; &#125;&#125; 样式中的编写，如果含有scope关键字，表示这些样式是组件局部的， 12345678&lt;style scoped&gt;.beauty&#123; width:100px; line-height:50px; border-bottom:1px solid #ddd; margin:0px auto;&#125;&lt;/style&gt; 路由配置 当拥有一个组件文件时，要在项目的src目录下的router目录下的index.js文件下 进行组件的路由加载配置 在导入组件文件时，可以使用@符号，代表从src目录起 比如：import index from ‘@/components/index’ 123456789101112131415161718192021import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import first from '@/components/first' // 从组件目录下导入组件文件，不需要加后缀import index from '@/components/index'Vue.use(Router)export default new Router(&#123; mode: 'history', routes: [ &#123; path: '/', component: index, &#125;, &#123; path: '/first', // 访问路径 component: first &#125; ] &#125;) 当配置好路由之后，需要在最主要的App.Vue文件下进行连接引入 通过&lt;router-link to=&quot;连接地址&quot;&gt;首页&lt;/router-link&gt;标签进行连接引入 通过&lt;router-view&gt;&lt;/router-view&gt;标签进行路由加载，可以简写为：&lt;router-view/&gt; 12345678910111213&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/first\"&gt;第一个页面&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在App.Vue文件下的template标签处如果已经引入了其他跳转连接； 那么在子组件的template部分不需要在进行引入 总结 编写components组件 index.js配置路由 在主入口App.vue中加载路由组件&lt;router-view/&gt;，一般默认已经写好","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Vue","slug":"Vue","date":"2019-10-21T02:57:05.032Z","updated":"2019-10-21T02:58:19.343Z","comments":true,"path":"2019/10/21/Vue/","link":"","permalink":"http://laxe.top/2019/10/21/Vue/","excerpt":"VUE Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增 Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的API实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言 Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统","text":"VUE Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增 Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的API实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言 Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统 Vue.js官方文档： https://cn.vuejs.org/v2/guide/ vue.js下载地址： https://cn.vuejs.org/v2/guide/installation.html npm配置cnpm windows下配置cnmp环境： 默认的使用NPM可能会因为网络问题而导致无法使用或延迟居高，可以使npm升级为cnpm，从国内淘宝镜像中加载所需的npm软件源 1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置安装包缓存路径 1cnpm config set cache \"C:\\nodejs\\node_cache\" 设置安装包位置 1cnpm config set prefix \"C:\\nodejs\\node_global\" 之后使用命令安装的模块存储在C:\\nodejs\\node_global\\node_modules里 请按照个人需求设置你的文件位置 1npm config set cache \"C:\\nodejs\\node_cache\" Vue部署 安装Vue 1cnpm install vue -g 安装vue脚手架 1cnpm install vue-cli -g -g参数代表全局位置安装，这样可以在环境变量生效的情况下直接在命令行等工具下使用vue命令行进行项目的开启 vue-devtools调试工具 vue-devtools可以方便开发者进行Vue中变量等信息的调试跟踪 下载vue-devtools 1git clone https://github.com/vuejs/vue-devtools 进入到vue-devtools目录下安装依赖包 123cd vue-devtools-devcnpm install cnpm run build 注意：在进行调试工具安装时，首先需要修改shells&gt;chrome文件夹下的mainifest.json中的persistent为true 将插件目录下的chrome文件夹拖入到chrome浏览器的扩展程序下，记得打开调试模式 扩展程序可以通过浏览器访问 1chrome://extensions/ Vue-CDN 除去通过npm安装的方式来使用vue，还可以直接使用cdn中的vue.js文件 vue.js：开发版本，包含了有帮助的命令行警告 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; vue.min.js：生产环境版本，优化了尺寸和速度 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; Vue语法 每个vue应用都是通过实例化一个新的vue对象开始的 创建第一个模板语法： 1234567891011&lt;div id=\"content\"&gt; &#123;&#123; message &#125;&#125; &lt;!-- 这个也叫做插值表达式 --&gt;&lt;/div&gt;var vm = new Vue(&#123; // vm这个变量不允许使用连字符，可以使用下划线，比如vm-data是不允许的 el: \"#content\", // 对应document中的一个标签，当vue对象创建后，这个标签内的区域就被接管 data: &#123; message: \"这是vue里的变量\" &#125;&#125;) 当一个vue实例被创建时，vue的响应式系统中加入了对其data对象中能找到的所有属性 当这些属性值被改变时，视图也会发生相应，并将对应属性更新为新的值 也可以通过定义函数来改变实例中data对象中的数据，数据改变，视图中的数据也将改变 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=\"ChangeMsg\"&gt;改变&lt;/button&gt; &lt;!-- 绑定点击事件为定义好的vue函数 --&gt;&lt;/div&gt;window.onload = function()&#123; var vm = new Vue(&#123; el: \"#app\", data: &#123; message: \"我对应的是message的变量\" &#125;, methods:&#123; // 定义一个函数 并绑定在按钮的点击事件上 ChangeMsg:function()&#123; this.message = \"我被改变了\"; // 修改当前实例中的message变量 &#125; &#125; &#125;)&#125; 这里的代码，将在点击按钮时，使当前的message变量发生变化 ``这样的语法有点类似一些Web框架，比如django的模板语言中的模板变量 返回值 除了直接定义某个变量的固定值进行页面渲染，模板变量还支持通过函数的返回值进行赋值 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123; classType &#125;&#125;学习&lt;/h1&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt; &lt;span&gt;&#123;&#123; describe() &#125;&#125;&lt;/span&gt;&lt;/div&gt;window.onload = function()&#123; var vm = new Vue(&#123; el: \"#app\", // getElementById('app') data: &#123; classType: \"vue\", content: \"这是vue的一个测试\", &#125;, methods:&#123; describe:function()&#123; return \"这是一个函数的返回值\" &#125;, &#125; &#125;)&#125; Vue模板指令 模板语法指的是如何将数据放入html中 Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层 Vue 实例的数据 所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和HTML 解析器解析 插入值，模板变量 数据绑定最常见的形式就是使用Mustache语法(双大括号) 的文本插值，也就是上面示例中的`` 内容绑定v-html 将内容按照html格式进行插入 123456789&lt;div id=\"app\"&gt; &lt;p v-html=\"contetn\"&gt;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: \"#app\", data: &#123; content: \"&lt;b&gt;段落标签&lt;/b&gt;文本内容\" &#125;,&#125;) 在网站上动态渲染任意HTML是非常危险的，因为容易导致XSS攻击 v-html一般只用在可信内容中，永不用在用户提交的内容上 v-text 将内容按照文本格式进行插入，但会覆盖原有标签内的内容，不会有加载的闪烁问题 123456789101112131415&lt;div id=\"app\"&gt; &lt;p v-text=\"contetn\"&gt;&lt;/p&gt; &lt;p&gt; &#123;&#123; gender ? '男' : '女' &#125;&#125; &lt;!-- ok? true:false --&gt; &lt;/p&gt; &lt;/div&gt;var vm = new Vue(&#123; el: \"#app\", data: &#123; gender: true, // 变量值为true时，显示模板变量中左边的值 content: \"&lt;b&gt;段落标签&lt;/b&gt;文本内容\" &#125;,&#125;) v-cloak 解决使用差值表达式时页面渲染过程，由于变量没有初始化而导致的闪烁问题 通俗的来说，比如变量的实际内容没有被创建，那么此时页面只会展示出这样的效果，之后当变量初始化之后，``将变化为实际的值，此时变化的过程我们称作闪烁 这个指令可以隐藏未编译的标签直到实例准备完毕 123456789101112&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: \"#app\", data:&#123; message: \"测试\", &#125; &#125;)&lt;/script&gt; 在上面的代码中，如果网速够慢的清空下，页面首先加载显示出的内容是`` 解决办法：通过v-clock指令，在使用到模板变量的标签上写入，并设置一个v-clock的类样式 12345678&lt;style type=\"text/css\"&gt; [v-cloak]&#123; display: none; &#125;&lt;/style&gt;&lt;div v-cloak id=\"app\"&gt; &lt;p v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 属性绑定v-bind 如果我们需要设置的模板变量是一个属性，比如a标签的href属性 1234567891011&lt;div id=\"app\"&gt; &lt;a v-bind:href=\"message\"&gt;连接&lt;/a&gt; &lt;a :href=\"message +'abc'\"&gt;连接&lt;/a&gt; &lt;!-- 属性内的模板变量写法已被移除，使用v-bind:attr 或 :attr --&gt;&lt;/div&gt;var vm = new Vue(&#123; el: \"#app\", data: &#123; message: \"https://www.baidu.com\" &#125;&#125;) 可以通过v-bind指令或者:的简写对某个dom元素的属性进行绑定 在下面还有更加详细的属性绑定示例 事件绑定v-on 给元素绑定对应事件，以下是对于点击事件的绑定 123456789101112&lt;div id=\"app\"&gt; &lt;button v-on:click=\"show\"&gt;按钮&lt;/button&gt; &lt;button @click=\"show\"&gt;按钮&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: \"#app\", method: &#123; show: function()&#123; alert(\"弹一下\") &#125; &#125;&#125;) 跑马灯效果 这里有一个跑马灯效果可以玩耍 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;h3 v-html=\"message\"&gt;&lt;/h3&gt; &lt;button @click=\"start\"&gt;开始&lt;/button&gt; &lt;button @click=\"stop\"&gt;停止&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: \"#app\", data: &#123; message: \"这是一个跑马灯\", sT: null, // 定时器实例 &#125;, methods:&#123; work()&#123; this.message = this.message.substring(1) + this.message[0] // 循环定时器所作的事情 &#125;, start()&#123; if (this.sT==null) &#123; // 判断此时是否已有定时器开启 console.log(\"开启定时器\") this.sT = setInterval(this.work,400) &#125; else &#123; console.log(\"已经开启 不在开启\") &#125; &#125;, stop()&#123; // 关闭定时器 设置定时器变量为null console.log(\"关闭定时器\") clearInterval(this.sT) this.sT = null &#125; &#125; 绑定事件修饰符阻止冒泡 比如一个按钮在一个div中，并且按钮和div均有自己的事件，那么此时点击按钮，事件会像冒泡一样从按钮开始一直到div进行触发，.stop修饰符用来阻止默认的事件触发行为 12345678910111213141516171819&lt;div id=\"fDiv\" @click=\"divClick\"&gt; &lt;button id=\"fBtn\" @click=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#fDiv\", // 控制区域 data: &#123;&#125;, methods: &#123; divClick()&#123; console.log(\"div被点击了\") &#125;, btnClick()&#123; console.log(\"按钮被点击了\") &#125; &#125;, &#125;) &#125;&lt;/script&gt; 通过.stop修饰阻止冒泡 123&lt;div id=\"fDiv\" @click=\"divClick\"&gt; &lt;button id=\"fBtn\" @click.stop=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt; 阻止默认行为 比如像a标签这样的，在点击时他有默认的跳转动作，可以通过.prevent阻止该默认行为 1234567891011&lt;div id=\"fDiv\"&gt; &lt;a href=\"https://www.baidu.com\" @click.prevent=\"aLink\"&gt;去百度&lt;/a&gt;&lt;/div&gt;var vm = new Vue()&#123; el: \"#fDiv\", methods:&#123; aLink()&#123; console.log(\"连接被点击\") &#125; &#125; &#125; 捕获事件 默认的事件触发处理机制是冒泡机制，capture代表具有该修饰的事件，会优先触发，脱离冒泡顺序； 也可理解为谁有该修饰符，先触发谁的事件 12345678910111213141516171819&lt;div id=\"fDiv\" @click.capture=\"divClick\"&gt; &lt;button id=\"fBtn\" @click=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#fDiv\", // 控制区域 data: &#123;&#125;, methods: &#123; divClick()&#123; console.log(\"div被点击了\") &#125;, btnClick()&#123; console.log(\"按钮被点击了\") &#125; &#125;, &#125;) &#125;&lt;/script&gt; 自身事件 与capture和冒泡不同，.self只有是自身触发的当前的事件才真正执行处理的回调函数 并且.self只会阻止当前元素的事件触发行为 1234&lt;div id=\"fDiv\" @click.self=\"divClick\"&gt; &lt;button id=\"fBtn\" @click.self=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;// 与上同 单次事件 使用.once只触发一次事件函数 123456789101112&lt;div id=\"fDiv\"&gt; &lt;a href=\"https://www.baidu.com\" @click.prevent.once=\"aLink\"&gt;去百度&lt;/a&gt; &lt;!-- 连接无法跳转的阻止事件 只会出现一次 --&gt;&lt;/div&gt;var vm = new Vue()&#123; el: \"#fDiv\", methods:&#123; aLink()&#123; console.log(\"连接被点击\") &#125; &#125; &#125; 表单双向绑定v-model 使用v-model指令可以在表单input、textarea以及select元素上创建双向数据绑定 根据表单上的值，自动更新模板变量中的值 v-model会忽略表单的初始值，比如：checked、value、selected，如果需要的话，应该在javascript中首先声明初始值 text1234567891011121314&lt;div id=\"container\"&gt; &lt;h3 v-html=\"message\"&gt;&lt;/h3&gt; &lt;input type=\"text\" v-model=\"message\"&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; message: \"这是个表单内容\", &#125;, &#125;) &#125;&lt;/script&gt; textarea12345&lt;div id=\"container\"&gt; &lt;h3 v-html=\"message\"&gt;&lt;/h3&gt; &lt;textarea v-model=\"message\"&gt;&lt;/textarea&gt;&lt;/div&gt;// 同上 checkbox 单个复选框：数据为绑定为true和false的布尔值 1234567891011121314&lt;div id=\"container\"&gt; &lt;h3 v-html=\"checked\"&gt;&lt;/h3&gt; &lt;input type=\"checkbox\" v-model=\"checked\"&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; checked: true, &#125;, &#125;) &#125;&lt;/script&gt; 多个复选框：选中的结果会绑定到同一个数组，将保存的v-model变量创建为数组 12345678910111213141516&lt;div id=\"container\"&gt; &lt;h3 v-html=\"checked\"&gt;&lt;/h3&gt; &lt;input name=\"fruit\" type=\"checkbox\" value=\"apple\" v-model=\"checked\"&gt;苹果 &lt;input name=\"fruit\" type=\"checkbox\" value=\"banana\" v-model=\"checked\"&gt;香蕉 &lt;input name=\"fruit\" type=\"checkbox\" value=\"orange\" v-model=\"checked\"&gt;橘子&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; checked: new Array, &#125;, &#125;) &#125;&lt;/script&gt; radio123456789101112131415&lt;div id=\"container\"&gt; &lt;h3 v-html=\"picked\"&gt;&lt;/h3&gt; &lt;input type=\"radio\" name=\"gender\" value=\"junior\" v-model=\"picked\"&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"girl\" v-model=\"picked\"&gt;女&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; picked: \"哈哈哈哈\", &#125;, &#125;) &#125;&lt;/script&gt; select12345678910111213141516171819&lt;div id=\"container\"&gt; &lt;h3 v-html=\"selected\"&gt;&lt;/h3&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;你想去哪&lt;/option&gt; &lt;option value=\"山西\"&gt;山西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; selected: \"\", &#125;, &#125;) &#125;&lt;/script&gt; selects 设置select标签的multiple属性即可设置为多选下拉菜单，按着ctrl键可以多选 123456789101112131415161718&lt;div id=\"container\"&gt; &lt;h3 v-html=\"selecteds\"&gt;&lt;/h3&gt; &lt;select multiple v-model=\"selecteds\"&gt; &lt;option value=\"上衣\"&gt;上衣&lt;/option&gt; &lt;option value=\"裤子\"&gt;裤子&lt;/option&gt; &lt;option value=\"鞋\"&gt;鞋&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; selecteds: new Array, // 多重数据一般都要保存成数组 &#125;, &#125;) &#125;&lt;/script&gt; 修饰符.lazy 默认情况下，v-model在input和textarea表单中进行同步输入框的改动 添加了.lazy修饰符之后，对应的v-model绑定事件触发机制将变为change事件，只有在光标失去焦点时会触发 1234567891011121314&lt;div id=\"container\"&gt; &lt;h3 v-html=\"message\"&gt;&lt;/h3&gt; &lt;input type=\"text\" v-model.lazy=\"message\"&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; message: \"这是个表单内容\", &#125;, &#125;) &#125;&lt;/script&gt; .number 如果用户希望将输入表单的内容处理为Number类型，可以使用.number给v-model进行修饰；如果表单字符串无法被处理为数字，则返回原始的值 1234&lt;div id=\"container\"&gt; &lt;h3 v-html=\"typeof message\"&gt;&lt;/h3&gt; &lt;input type=\"text\" v-model.number=\"message\"&gt;&lt;/div&gt; .trim 使用.trim可以自动过滤输入框的首尾空格 123456&lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model.trim=\"message\"&gt; &lt;br&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;!-- 通过查看另一个表单中同步的缩进 --&gt;&lt;/div&gt; 动态绑定 当某些情况下，无法确定表单中所代表的属性值，可以使用v-bind进行动态绑定，v-model获取到的表单输入此时则是我们定义的v-bind属性值 123456789101112131415161718&lt;div id=\"container\"&gt; &lt;h3 v-html=\"message\"&gt;&lt;/h3&gt; &lt;input type=\"radio\" v-model=\"message\" :value=\"choiceA\"&gt; A &lt;input type=\"radio\" v-model=\"message\" :value=\"choiceB\"&gt; B&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; message: \"\", // 表单绑定变量 choiceA: \"Yes!\", // 属性绑定变量，未来不需要修改标签中的value值即可动态修改 choiceB: \"No!\", &#125;, &#125;) &#125;&lt;/script&gt; 计算属性 关键词：computed 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的 在模板中放入太多的逻辑会让模板过重且难以维护 也就是说，某些时候页面中的模板变量如果需要复杂的运算处理，应该使用计算属性，而不是直接在模板位置进行计算。 12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; String1:\"这是一个字符串\", &#125;, methods: &#123; MreverseString()&#123; return this.String1.split(\"\").reverse().join(\"\") &#125; // 定义一个函数进行字符串逆置 &#125;, computed: &#123; CreverseString()&#123; return this.String1.split(\"\").reverse().join(\"\") &#125; // 定义一个计算属性进行字符串逆置 &#125; &#125;) &#125;&lt;/script&gt;&lt;div v-cloak id=\"container\"&gt; &lt;p&gt;这是一个字符串:&#123;&#123; String1 &#125;&#125; &lt;/p&gt; &lt;p&gt;他的逆置:&#123;&#123; String1.split(\"\").reverse().join(\"\") &#125;&#125; &lt;/p&gt; &lt;p&gt;他的逆置:&#123;&#123; CreverseString &#125;&#125; &lt;/p&gt; &lt;!-- 计算属性直接写入函数名 --&gt; &lt;p&gt;他的逆置:&#123;&#123; MreverseString() &#125;&#125; &lt;/p&gt; &lt;!-- 普通methods函数调用需加括号 --&gt;&lt;/div&gt; 注意：虽然计算属性和函数都可以达成同样的目的，但是computed会缓存结果，计算属性如果发现依赖的属性message未发生改变，再次访问计算属性不会重复运算函数，而是直接利用已有结果；如果依赖数据发生改动，计算属性函数才会重新运算。 在函数及计算属性中添加日志输出即可看到这个效果： 123456789101112methods: &#123; MreverseString() &#123; console.log(\"MreverseString被运算了\") return this.String1.split(\"\").reverse().join(\"\") &#125;&#125;,computed: &#123; CreverseString() &#123; console.log(\"CreverseString被运算了\") return this.String1.split(\"\").reverse().join(\"\") &#125;&#125; 在终端下进行计算属性以及函数的访问即可看到效果。 计算属性SetAttr 默认的计算属性只有获取getattr的方式，我们可以手动为他添加一个setter 1234567891011computed:&#123; CreverseString: &#123; get: function()&#123; return this.String1.split(\"\").reverse().join(\"\") &#125; set: function(val)&#123; this.String1 = val.split(\"\").reverse().join(\"\") // 如果当前的逆置之后字符串为val，那么原本的字符串需要再颠倒一次 &#125; &#125;&#125; 侦听属性 侦听属性的作用是侦听某些属性的变化，从而做相应的操作，进行对数据变化的相应， 侦听属性是一个对象（字典），key值是要监听的元素，值是当监听的元素发生改变时要执行的函数； 监听函数有两个参数，一个是当前值，另一个是变化后的值 比如监听一个变量的变化 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data:&#123; content: \"\", // 表单内容 count: 0, // 记录表单内用户敲了多少次 &#125;, watch:&#123; content:function (oldVal,newVal)&#123; // 只要在文本框输入内容影响到了age数据发生改变，就会触发 this.count += 1 &#125;， &#125;， &#125;) &#125;&lt;/script&gt;&lt;div id=\"container\"&gt; &lt;p&gt;&lt;label&gt;你敲了:&#123;&#123; count &#125;&#125;次&lt;/label&gt;&lt;/p&gt; &lt;input type=\"text\" placeholder=\"请输入你的年纪\" v-model=\"content\"&gt;&lt;/div&gt; 属性绑定 使用v-bind:class指令来设置元素的class属性； 属性表达式的类型可以是字符串、对象或数组 数组属性 可以通过为元素绑定一个数组，用来为元素设置单个或多个样式，类名在数组中用单引号 1234567891011&lt;style type=\"text/css\"&gt; .fontBold &#123; font-weight: bold; &#125; .fontRed &#123; color: red; &#125;&lt;/style&gt;&lt;div id=\"container\"&gt; &lt;p :class=\"['fontBold','fontRed']\"&gt;这是一个段落&lt;/p&gt;&lt;/div&gt; 动态属性 可以通过为元素绑定一个对象，对象的key是样式类，对象的value是true或false来动态切换class 12345678910111213141516171819202122232425&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; flag: true, &#125;, methods: &#123; toggle() &#123; if (this.flag)&#123; // 判断当前toggle变量的属性，对称变换 this.flag = false &#125;else&#123; this.flag = true &#125; &#125; &#125; &#125;) &#125;&lt;/script&gt;&lt;div id=\"container\"&gt; &lt;p :class=\"&#123;fontBold: flag&#125;\" @click=\"toggle\"&gt;这是一个段落&lt;/p&gt; &lt;p :class=\"&#123;flag? fontBold:''&#125;\" @click=\"toggle\"&gt;这是一个段落&lt;/p&gt; &lt;!-- 三元表达式 --&gt;&lt;/div&gt; 样式绑定 使用v-bind:style语法，为元素绑定样式 123&lt;p :style=\"&#123;color:'red','font-weight':'bold'&#125;\"&gt; 一段文字&lt;/p&gt; 也可以在vue的data中定义一个对象，用来描述样式，其中带有连字符的样式属性要加引号 123456789&lt;div id=\"container\"&gt; &lt;p :style=\"styleObj\"&gt;一段文字&lt;/p&gt;&lt;/div&gt;data: &#123; styleObj: &#123; color:'red', 'font-weight':'bold', &#125;&#125;, data中的对象也可以通过数组类型绑定到元素上 123456789101112&lt;div id=\"container\"&gt; &lt;p :style=\"[styleObj1,styleObj2]\"&gt;一段文字&lt;/p&gt; &lt;!-- 对于js的样式绑定不需要加引号，因为就是一个变量 --&gt;&lt;/div&gt;styleObj1: &#123; border: '1px solid gray', width: '100px',&#125;,styleObj2:&#123; background: 'black', color: 'blue',&#125; 条件渲染 通过条件指令可以控制元素的显示及隐藏，或者说叫做创建和销毁 v-if v-if指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候渲染 12345678910111213141516171819&lt;div v-cloak id=\"container\"&gt; &lt;h3 v-if=\"oh3\"&gt;h3标题&lt;/h3&gt; &lt;p v-if=\"gender === 'girl'\"&gt;你是女的&lt;/p&gt; &lt;p v-else-if=\"gender === 'boy'\"&gt;你是男的&lt;/p&gt; &lt;p v-else&gt;不男不女&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data:&#123; oh3:\"a\", gender: 'other' &#125;, &#125;) &#125;&lt;/script&gt; truthy和ture的区别： 隐含有true属性的变量不可以认为它是true，它不是boolean类型 v-show 与v-if不同的是，v-show 的元素始终会被渲染并保留在DOM中 12&gt; v-show` 只是简单地切换元素的`CSS`属性 `display&gt; 12345678910111213141516&lt;div v-cloak id=\"container\"&gt; &lt;h3 v-if=\"oh3\"&gt;h3标题&lt;/h3&gt; &lt;h4 v-show=\"oh4\"&gt;h4标题&lt;/h4&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data:&#123; oh3:\"1\", // v-if 在该变量不为真时直接消失在document中 oh4:\"1\", // v-show 处理不为真的变量条件 绑定元素不会消失 &#125;, &#125;) &#125;&lt;/script&gt; 列表渲染v-for 把一个数组对应为一组元素 用 v-for 指令根据一组数组的选项列表进行渲染 v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名 1234567891011121314151617181920&lt;ol id=\"container\"&gt; &lt;li v-for=\"user in users\"&gt; &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ol&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data:&#123; users: [ &#123;name:\"张三\",age:18&#125;, &#123;name:\"李四\",age:20&#125;, &#123;name:\"王五\",age:19&#125;, ] &#125;, &#125;) &#125;&lt;/script&gt; v-for还可以支持将当前循环索引作为渲染时的第二个参数，第二个参数为访问索引位置 12345678910&lt;p v-for=\"(user,index) in users\"&gt; &#123;&#123; index &#125;&#125;:&#123;&#123; user.age &#125;&#125;&lt;/p&gt;data:&#123; users: [ &#123;name:\"张三\",age:18&#125;, &#123;name:\"李四\",age:20&#125;, &#123;name:\"王五\",age:19&#125;, ]&#125;, 使用v-for迭代访问一个对象 12345678&lt;p v-for=\"key in myself\"&gt; &#123;&#123; key &#125;&#125; &lt;!-- 当v-for渲染时只有一个参数，此时参数为value值 --&gt;&lt;/p&gt;myself : &#123; name:\"赵六\", age:\"17\",&#125; v-for支持最多三个参数，同时获取遍历对象的key和value值，以及index索引位置 要注意的是，此时的key和value和python中的顺序是颠倒的，key在后，value在前 1234567&lt;p v-for=\"(value,key,index) in myself\"&gt; &#123;&#123; index &#125;&#125;: &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;&lt;/p&gt;myself : &#123; name:\"孙七\", age:\"17\",&#125; v-for进行一段取值 123456&lt;div&gt; &lt;p v-for=\"n in 8\"&gt; &#123;&#123; n &#125;&#125; &lt;/p&gt; &lt;!-- 1 2 3 4 5 6 7 8 --&gt;&lt;/div&gt; 选项卡练习1234567891011121314151617181920212223242526272829303132333435363738&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; choicId: null, &#125; &#125;) &#125;&lt;/script&gt;&lt;style&gt; li&#123; list-style-type: none; border: 3px outset lightgreen; width: 100px; background:lightblue; margin:5px; &#125; li:hover&#123; border: 3px inset gray; cursor: pointer; &#125; [v-cloak]&#123; display: none; &#125;&lt;/style&gt;&lt;div v-cloak id=\"container\"&gt; &lt;ol list&gt; &lt;li @click=\"choicId = 1\"&gt;A&lt;/li&gt; &lt;li @click=\"choicId = 2\"&gt;B&lt;/li&gt; &lt;li @click=\"choicId = 3\"&gt;C&lt;/li&gt; &lt;li @click=\"choicId = 4\"&gt;D&lt;/li&gt; &lt;/ol&gt; &lt;p v-show=\"choicId == 1\"&gt;aaaaaaaaaa&lt;/p&gt; &lt;p v-show=\"choicId == 2\"&gt;bbbbbbbbbb&lt;/p&gt; &lt;p v-show=\"choicId == 3\"&gt;cccccccccc&lt;/p&gt; &lt;p v-show=\"choicId == 4\"&gt;dddddddddd&lt;/p&gt;&lt;/div&gt; js中两个等号和三个等号的区别： ==表示： 如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较；equality等同 ===表示：不需要做类型转换，如果两边值的类型不同，就表示一定是不等的identity恒等 注意 Vue无法检测到对于数组的索引设置及长度修改以及对于对象属性的删除或添加 但是可以通过以下方式进行属性添加触发状态更新 123Vue.set($vm.Object,\"key\",\"val\") // 对于对象 这样的添加方式可以触发状态更新Vue.set($vm.Array, index, newVal) // 对于数组 添加元素 触发状态更新// vm.items.splice(newLength) // 设置数组长度 javascript.splice(where, num, [additem1,additem2...] )：删除或添加元素 此外，当v-for与v-if同时使用时，v-for有更高的优先级，这会造成重复遍历得到的元素都要在做一次v-if的判断，如果我们是为了有目的判断当前是否需要渲染这个元素，或是跳过这个循环，可以将v-if放在外层元素，比如template标签中，(template标签无实际意义，默认不展示，但是可以起到包裹作用) 过滤器 Vue.js允许你自定义过滤器，可被用于一些常见的文本，对它们进行格式化 过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持) 过滤器应该被添加在JavaScript表达式的尾部，由管道符号指示 语法 12345&lt;p&gt; &#123;&#123; message | filter &#125;&#125;&lt;/p&gt;&lt;p v-bind:type=\"message | filter\"&gt; &lt;/p&gt; 过滤器本质上是一个函数，比如我们定义一个将表单输入的内容中所有的字母变大写的过滤器 1234567891011121314151617181920212223&lt;body&gt; &lt;div v-cloak id=\"container\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;p&gt;展示: &#123;&#123; message | toUpper &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; message: \"\", &#125;, filters: &#123; toUpper: function (value) &#123; if (!value) return '' // 字符串内容为空 直接返回 console.log(\"正在变大小\") return String(value).toUpperCase() &#125; &#125; &#125;) &#125;&lt;/script&gt; 过滤器函数也可以有多个参数 1234567891011121314&#123;&#123; message | filter(arg1, arg2) &#125;&#125;// message 第一个参数// arg1 第二个参数// arg2 第三个参数&lt;div v-cloak id=\"container\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;p&gt;展示: &#123;&#123; message | toLong(\"| \",\" |\") &#125;&#125;&lt;/p&gt;&lt;/div&gt;filters: &#123; toLong(value,arg1,arg2)&#123; if (!value) return '' return arg1 + value + arg2 &#125;&#125; Vue实例生命周期 每个Vue实例在被创建时都要经过一系列的初始化过程 例如：需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等 同时在这个过程中会自动运行一些叫做生命周期钩子的函数，我们可以使用这些函数，在实例的不同阶段加上我们需要的代码，实现特定的功能 beforeCreate：数据还没有监听，没有绑定到vue对象实例，同时也没有挂载对象 created：数据已经绑定到了对象实例，但是还没有挂载对象 beforeMount：模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的$el属性 $el属性是一个HTMLElement对象，也就是这个阶段，vue实例通过原生的createElement等方法来创建这个html片段，准备注入到我们vue实例指明的el属性所对应的挂载点 mounted： 将$el的内容挂载到了el，相当于我们在jQuery执行了$(el).html($el)，生成页面上真正的dom 上面我们就会发现页面的元素和我们$el的元素是一致的；在此之后，我们能够用方法来获取到el元素下的dom对象，并进行各种操作 beforeUpdate：数据发生变化时调用 updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子 beforeDestroy：Vue实例销毁前 destroyed：Vue实例销毁后 12&gt; window.$vm.$destroy()&gt; 一大段代码进行钩子函数的调用过程监控 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; function showData(process, vm) &#123; console.log(process) console.log(\"vue数据:\", vm.message) // 当前Vue中的数据 console.log(\"Vue挂载el:\") // Vue接管的元素 console.log(vm.$el) console.log(\"真实Dom:\") console.log(document.getElementById(\"container\").innerHTML) console.log('-----------------') &#125; // 这个函数用来输出相关信息的 new Vue(&#123; el: \"#container\", data: &#123; message: \"aaaaa\", &#125;, beforeCreate: function () &#123; showData(\"创建Vue实例前\", this) &#125;, created: function () &#123; showData(\"创建Vue实例后\", this) &#125;, beforeMount: function () &#123; showData(\"挂载到Dom前\", this) &#125;, mounted: function () &#123; showData(\"挂载到Dom后\", this) &#125;, beforeUpdate: function () &#123; showData(\"数据发生变化时\", this) &#125;, updated: function () &#123; showData(\"数据发生变化后\", this) &#125;, beforeDestroy: function () &#123; showData(\"Vue实例销毁前\", this) &#125;, destroyed: function () &#123; showData(\"Vue实例销毁后\", this) &#125; &#125;)&#125;&lt;/script&gt;&lt;div id=\"container\"&gt; &lt;p v-html=\"message\"&gt;&lt;/p&gt;&lt;/div&gt; 组件ES6语法 ES6是JavaScript语言的新版本，它也可以叫做ES2015，之前学习的JavaScript属于ES5，ES6在它的基础上增加了一些语法 ES6是未来JavaScript的趋势，而且vue组件开发中会使用很多的ES6的语法，所以掌握这些常用的ES6语法是必须的 变量声明 let：定义封闭作用域的变量，并且变量只能声明一次 const：定义封闭作用域的常量，并且变量只能声明一次 let和const是新增的声明变量的开头的关键字，在这之前，变量声明是用var关键字 这两个关键字和var的区别是，它们声明的变量没有预解析，无法脱离定义空间使用 let和const的区别是，let声明的是一般变量，const申明的常量，不可修改 12345678910console.log(a) // undefinedconsole.log(b) // b is not definedconsole.log(c) // c is not definedvar a = 1var a = 2let b = 2// let b = 3 // Identifier 'b' has already been declaredconst c = 3// const c = 4 // Identifier 'c' has already been declaredc = 4 // Assignment to constant variable 箭头函数 可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定this 解决了JavaScript中this指定混乱的问题 定义函数的一般方式 123function func()&#123; ...&#125; 匿名赋值创建函数 123var func = function()&#123; ...&#125; 箭头函数的写法 123456789101112131415161718192021222324var func = (a, b) =&gt; &#123; // 这样的函数在嵌套时，会自动绑定外部作用域下的this&#125;var func = a =&gt; &#123; // 一个参数时，可以省略参数&#125;window.onload = function () &#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; message: \"abcdef\", &#125;, methods: &#123; show() &#123; console.log(\"这是show函数:\", this.message), func = () =&gt; &#123; console.log(\"我是内部函数:\", this.message) &#125;, func(), // 调用一下这个内部函数 &#125; &#125; &#125;)&#125;&lt;div id=\"container\"&gt; &lt;button @click=\"show\"&gt;按钮&lt;/button&gt;&lt;/div&gt; Vue组件 组件Component是Vue.js最强大的功能之一 组件可以扩展HTML元素，封装可重用的代码 所有的Vue组件同时也都是Vue的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命周期钩子 注册全局组件 注册一个全局组件语法格式如下 123Vue.component(tagName, options)// tagName：组件名// options：配置选项 比如这样一个全局组件 123456789Vue.component('button_show', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, // 当前组件会需要的数据，定义为函数的返回值 template: '&lt;button @click=\"count++\"&gt;按钮:&#123;&#123; count &#125;&#125;&lt;/button&gt;' // 组件的标签模板&#125;) 接下来可以在任何Vue接管的元素中使用该组件， 12345678&lt;div id=\"container\"&gt; &lt;button_show&gt;&lt;/button_show&gt;&lt;/div&gt;window.onload = function () &#123; var vm = new Vue(&#123; el: \"#container\", &#125;)&#125; data必须是函数 组件就是vue的实例，所有vue实例中属性和方法，组件中也可以用 其中data属性必须是一个函数，因为组件会重复使用在多个地方，为了使用在多个地方的组件数据相对独立，data属性需要用一个函数的返回值来将数据处理为不同的每个个体 Prop传递数据 Prop是你可以在组件上注册的一些自定义特性 当一个值传递给一个prop特性的时候，它就变成了那个组件实例的一个属性 为了给组件传递数据，我们可以用一个 props 选项将一些特性值列举在其中 12345678910111213141516171819202122232425&lt;script type=\"text/javascript\"&gt; Vue.component(\"myp\",&#123; props: [\"content\",\"like\"], // 需要两个外界传入的值 template: \"&lt;p :class='like'&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;\" // 组件绑定未来要接受的变量，要用到v:bind &#125;) window.onload = function()&#123; var vm = new Vue(&#123; el: \"#container\", data: &#123; content: '这是p段落的文本', like: 'beauty', // 要传递的变量 &#125; &#125;) &#125;&lt;/script&gt;.beauty&#123; width: 100px; color: red; background: green;&#125;&lt;div id=\"container\"&gt; &lt;myp :like=\"like\" :content=\"content\"&gt;&lt;/myp&gt; &lt;!-- 传递到组件中 --&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"jQuery","slug":"jQuery","date":"2019-10-21T02:55:28.832Z","updated":"2019-10-21T02:56:42.287Z","comments":true,"path":"2019/10/21/jQuery/","link":"","permalink":"http://laxe.top/2019/10/21/jQuery/","excerpt":"jQuery jQuery是一个JavaScript函数库。 jQuery是一个轻量级的JavaScript库。 jQuery库包含以下功能： 1234567- HTML 元素选取- HTML 元素操作- CSS 操作- HTML 事件函数- JavaScript 特效和动画- HTML DOM 遍历和修改- AJAX 异步加载","text":"jQuery jQuery是一个JavaScript函数库。 jQuery是一个轻量级的JavaScript库。 jQuery库包含以下功能： 1234567- HTML 元素选取- HTML 元素操作- CSS 操作- HTML 事件函数- JavaScript 特效和动画- HTML DOM 遍历和修改- AJAX 异步加载 jQuery介绍 jQuery是目前使用最广泛的javascript函数库。据统计，全世界排名前100万的网站，有46%使用jQuery，远远超过其他库 微软公司甚至把jQuery作为他们的官方库 jQuery的版本分为1.x系列和2.x、3.x系列，1.x系列兼容低版本的浏览器；2.x、3.x系列放弃支持低版本浏览器，目前使用最多的是1.x系列的 jquery是一个函数库，一个js文件，页面用script标签引入这个js文件就可以使用 1&lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; 下载jQuery 官网：http://jquery.com/ 下载：https://code.jquery.com/ 基础语法123456789101112&lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready( function()&#123; $(\"p\").click( function()&#123; console.log($(this).css(\"color\")) $(this).css(\"color\",\"red\"); &#125;); &#125;)&lt;/script&gt;&lt;body&gt; &lt;p style=\"color: blue;\"&gt;我会变红&lt;/p&gt;&lt;/body&gt; Jquery基础语法：Query 语法是通过选取 HTML 元素，并对选取的元素执行某些操作 1$(selector).action() 美元符号定义jQuery 选择符（selector）查询和查找HTML元素 jQuery的action()执行对元素的操作 文档就绪事件 这是为了防止文档在完全加载（就绪）之前运行jQuery代码，jQuery的代码经常会位于一个document ready函数中 12345$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;); 注意 jQuery入口函数与JavaScript入口函数的区别 jQuery的入口函数是在html所有标签(DOM)都加载之后，就会去执行 JavaScript的window.onload事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行 jQuery选择器 jQuery的选择器可以更加方便我们对页面的DOM元素进行操作，而原生的操作方式是比较痛苦的 元素选择器 jQuery选择器允许对HTML元素组或单个元素进行操作 123456789101112131415161718&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"p\").click(function()&#123; $(this).css(\"color\",\"red\"); &#125;); &#125;); &lt;/script&gt; &lt;!-- 当某个p被点击时，都会触发该js函数 --&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是第一个p&lt;/p&gt; &lt;p&gt;我是第二个p&lt;/p&gt; &lt;p&gt;我是第三个p&lt;/p&gt;&lt;/body&gt; ID选择器 ID选择器通过HTML元素的ID属性选取指定的元素 页面中的元素的id应该是唯一的，在页面中选取唯一的元素需要#id选择器 1234567891011121314151617&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"#change\").click(function()&#123; $(this).css(\"color\",\"red\"); // css属性函数 &#125;); &#125;); &lt;/script&gt; &lt;!-- 当Id值为change的p标签被点击时，触发该js函数 --&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是第一个p&lt;/p&gt; &lt;p&gt;我是第二个p&lt;/p&gt; &lt;p id=\"change\"&gt;我是第三个p&lt;/p&gt;&lt;/body&gt; 类选择器 通过元素的class属性进行查找 123456789101112131415161718&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\".pClass\").hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"pClass\"&gt; 这是测试内容，点击按钮后，这里的东西会消失 &lt;/p&gt; &lt;button&gt; 点击 &lt;/button&gt;&lt;/body&gt; 其他选择器 语法 描述 $(this) 选取当前HTML元素 $(&quot;*&quot;) 选取所有元素 $(&quot;p.intro&quot;) 选取class为intro的&lt;p&gt;元素 $(&quot;p:first&quot;) 选取第一个&lt;p&gt; 元素 $(&quot;ul li:first&quot;) 选取第一个&lt;ul&gt;元素的第一个&lt;li&gt;元素 $(&quot;ul li:first-child&quot;) 选取每个&lt;ul&gt;元素的第一个&lt;li&gt;元素 $(&quot;[href]&quot;) 选取带有href属性的元素 $(&quot;a[target=&#39;_blank&#39;]&quot;) 选取所有target属性值等于_blank的&lt;a&gt;元素 $(&quot;:button&quot;) 选取所有type=&quot;button&quot;的 &lt;input&gt;元素 和&lt;button&gt;元素 $(&quot;tr:odd&quot;) 选取奇数位置的&lt;tr&gt;元素 jQuery遍历 在查找时,可以通过遍历,相对于某些元素进行位置查找,从而获取到想要的元素位置 先要分清楚在HTML中元素的级别关系 12345678910111213&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;a&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt; b &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;- &lt;div&gt; 元素是 &lt;ul&gt; 的父元素，同时是其中所有内容的祖先。- &lt;ul&gt; 元素是 &lt;li&gt; 元素的父元素，同时是 &lt;div&gt; 的子元素- 左边的 &lt;li&gt; 元素是 &lt;span&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。- &lt;span&gt; 元素是 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。- 两个 &lt;li&gt; 元素是同胞（拥有相同的父元素）。- 右边的 &lt;li&gt; 元素是 &lt;a&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。- &lt;a&gt; 元素是右边的 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。 祖先遍历 parent()：返回被选择元素的直接父元素 1234567891011121314151617181920212223242526&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"span\").parent().css(\"border\",\"1px solid red\"); &#125;); &lt;/script&gt; // 这里选择到了全部span标签的父标签,li标签,并且设置红色2像素边框&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;普通内容1&lt;/span&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;span&gt;普通内容2&lt;/span&gt; &lt;br&gt; &lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; parents()：返回被选择元素的全部父元素 12345678910111213141516171819202122&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"span\").parents().css(\"border\",\"1px solid red\"); &#125;); // 选中了li标签 ul标签 div标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;普通内容1&lt;/span&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 该方法也可以指定父元素中的某些元素进行二次过滤，比如选择所有父元素中类为father的元素 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"span\").parents(\".father\").css(\"border\",\"1px solid red\"); &#125;); // 找到了 div标签和ul标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"father\"&gt; &lt;ul class=\"father\"&gt; &lt;li&gt; &lt;span&gt;普通内容1&lt;/span&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; parentsUntil(&quot;limit&quot;)：向上查找,直到找到元素界限为止之前的所有父元素 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"span\").parentsUntil(\"div\").css(\"border\",\"1px solid red\"); &#125;); // 找到了 ul标签 第一个li标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"father\"&gt; &lt;ul class=\"father\"&gt; &lt;li&gt; &lt;span&gt;普通内容1&lt;/span&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后代遍历 children()：返回被选元素的直接子元素，不会继续向深层次遍历 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"li\").children().css(\"border\",\"1px solid red\"); &#125;); // 找到了 span标签 a标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"father\"&gt; &lt;ul class=\"father\"&gt; &lt;li&gt; &lt;span&gt;普通内容1&lt;/span&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; find(&quot;*&quot;)：返回被选元素的所有符合条件的直接子元素，会继续向深层次遍历 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"ul\").find(\"*\").css(\"border\",\"1px solid red\"); &#125;); // 找到了 两个li标签 span标签 a标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"father\"&gt; &lt;ul class=\"father\"&gt; &lt;li&gt; &lt;span&gt;普通内容1&lt;/span&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同胞遍历 siblings()：返回被选元素的所有同胞元素 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"span\").siblings().css(\"border\",\"1px solid red\"); &#125;); // 找到了 p标签 h标签 strong标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"father\"&gt; &lt;p&gt;一个p标签&lt;/p&gt; &lt;span&gt;一个span标签&lt;/span&gt; &lt;h3&gt;一个h标签&lt;/h3&gt; &lt;strong&gt;一个strong标签&lt;/strong&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; next()：返回被选元素的下一个同胞元素，只返回一个元素 nextAll()：返回被选元素的所有下面的同胞元素，返回所有跟随同胞 nextUntil(&quot;limit&quot;)：返回直到limit界限的所有跟随同胞，不包含limit 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"span\").next().css(\"border\",\"1px solid red\"); &#125;); // 找到了 h标签 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"father\"&gt; &lt;p&gt;一个p标签&lt;/p&gt; &lt;span&gt;一个span标签&lt;/span&gt; &lt;h3&gt;一个h标签&lt;/h3&gt; &lt;strong&gt;一个strong标签&lt;/strong&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 过滤方法 语法 描述 first() 返回被选元素的首个元素 last() 返回被选元素的最后个元素 eq() 返回被选元素中带有指定索引号的元素，索引从0开始 filter() 规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回 not() 返回不匹配标准的所有元素，与filter相反 1234$(\"h3\").filter(\".suit\");// 选择所有类名为suit的h3标签$(\"p\").not(\".green\");// 过滤所有类名为green的p标签 判断是否选择到了元素 jquery有容错机制，即使没有找到元素，也不会出错 可以用length属性来判断是否找到了元素，length等于0，就是没选择到元素；length大于0，就是选择到了元素 12var oh = $(\"h1\");alert(oh.length) // &gt; 1 | 0 jQuery样式操作获取样式 $(&quot;selector&quot;).css(&quot;attr&quot;) 12$(\"div\").css(\"color\"); // rgb(255, 0, 0)$(\"div\").css(\"border\"); // 1px solid rgb(128, 128, 128) 设置样式 $(&quot;selector&quot;).css(&quot;attr&quot;,&quot;xxx&quot;) $(&quot;selector&quot;).css({&quot;attr1&quot;: &quot;xxx&quot;, &quot;attr2&quot;: &quot;yyy&quot;}) 12$(\"div\").css(\"color\",\"blue\");$(\"div\").css(&#123;\"color\":\"blue\", \"border\":\"1px dashed yellow\"&#125;); 注意:如果选择器div选择到了多个,在获取信息时,只取第一个 其他操作样式的方式 addClass()：向被选元素添加一个或多个属性 1234567891011121314151617&lt;style type=\"text/css\"&gt;.redFont&#123; color: red;&#125;.blueBoder&#123; border: 1px solid blue;&#125;&lt;/style&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\".father\").addClass(\"redFont blueBoder\"); &#125;);&#125;);&lt;div class=\"father\"&gt; 这是个div&lt;/div&gt;&lt;button&gt;按钮&lt;/button&gt; removeClass()：删除指定的class属性 1234567891011121314151617&lt;style type=\"text/css\"&gt; .redFont&#123; color: red; &#125; .blueBoder&#123; border: 1px solid blue; &#125;&lt;/style&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\".redFont\").removeClass(\"blueBoder\"); &#125;);&#125;);&lt;div class=\"blueBoder redFont\"&gt; 这是个div&lt;/div&gt;&lt;button&gt;按钮&lt;/button&gt; toggleClass()：设置或移除被选元素的一个或多个类进行切换 该方法检查每个元素中指定的类 如果不存在则添加类，如果已设置则删除之。这就是所谓的切换效果 123456789101112131415&lt;div class=\"blueBoder redFont\"&gt; 这是个div&lt;/div&gt;&lt;button&gt;按钮&lt;/button&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").toggleClass(\"redFont\"); &#125;);&#125;);&lt;p class=\"redFont\"&gt;第一段文字&lt;/p&gt;&lt;p class=\"redFont\"&gt;第二段文字&lt;/p&gt;&lt;p&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt;&lt;h3&gt;这是h3标题&lt;/h3&gt;&lt;button&gt;按钮&lt;/button&gt; jQuery事件鼠标事件 click：点击 123$(selector).click(function()&#123; ... &#125;); dbclick：双击 123$(selector).dbclick(function()&#123; ... &#125;); mouseenter：穿过某元素 123$(selector).mouseenter(function()&#123; ... &#125;); moseleave：鼠标离开 123$(selector).mouseleave(function()&#123; ... &#125;); hover：鼠标悬停 123$(selector).hover(function()&#123; ...&#125;); 键盘事件 keydown：键按下的过程 123$(selector).keydown(function()&#123; //&#125;); keypress：键被按下 123456789i = 0$(document).ready(function()&#123; $(\"input\").keypress(function()&#123; $(\"span\").text(i+=1); &#125;);&#125;);// 在input表单中按了多少次&lt;input type=\"text\"&gt;&lt;p&gt;按键的次数: &lt;span&gt;0&lt;/span&gt;&lt;/p&gt; keyup：键被松开 123$(selector).keyup(function()&#123; // &#125;); 表单事件 submit：表单提交 123$(\"form\").submit(function()&#123; alert(\"表单被提交\");&#125;); change：表单修改 123$(\"input\").change(function()&#123; alert(\"文本已被修改\");&#125;); 注意：当用于select元素时，change事件会在选择某个选项时发生。当用于text field或text area 时，change事件会在元素失去焦点时发生 focus：光标选中 123456$(\"input\").focus(function()&#123; $(\"label\").fadeOut(2000);&#125;);// 当输入框被选中时，label标签淡出 fadeOut&lt;label&gt;看看这个文字&lt;/label&gt;&lt;input type=\"text\"&gt; blur：光标离开 123$(\"input\").blur(function()&#123; alert(\"输入框失去了焦点\");&#125;); 文档/窗口事件 load：指定元素已加载 load()方法在jQuery版本1.8中已废弃 123$(\"img\").load(function()&#123; alert(\"图片已载入\");&#125;); resize：当调整浏览器窗口大小时，发生resize事件 1234$(window).resize(function()&#123; $(\"span\").text(i+=1);&#125;);&lt;span&gt;0&lt;/span&gt;次 scroll：当用户滚动指定的元素时，会发生scroll事件 scroll事件适用于所有可滚动的元素和window对象（浏览器窗口） 123$(\"div\").scroll(function()&#123; $(\"span\").text(x+=1);&#125;); unload：当用户离开页面时，会发生unload事件 unload()方法在jQuery版本1.8中已废弃，在3.0版本被移除 1234$(window).unload(function()&#123; alert(\"Goodbye!\");&#125;);// unload() 方法只应用于 window 对象 获取内容和属性 text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容（包括HTML标记） 123456&lt;p&gt;这是个&lt;b&gt;p&lt;/b&gt;标签&lt;/p&gt; &lt;button&gt;按钮&lt;/button&gt;$(\"button\").click(function()&#123; console.log($(\"p\").text()); // 这是个p标签 console.log($(\"p\").html()); // 这是个&lt;b&gt;p&lt;/b&gt;标签&#125;); val()：设置或返回表单字段的值 12345&lt;input type=\"text\" value=\"123\"&gt;&lt;button&gt;按钮&lt;/button&gt;$(\"button\").click(function()&#123; console.log($(\"input\").val());&#125;); attr(&quot;src&quot;)：获取属性 123456&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;button&gt;按钮&lt;/button&gt;$(\"button\").click(function()&#123; console.log($(\"a\").attr(\"href\")); // https://www.baidu.com&#125;);// 获取a标签的href属性 改变内容和属性 text()、html()、val() 123456789$(\"button\").click(function()&#123; $(\"#test1\").text(\"Hello world!\");&#125;);$(\"button\").click(function()&#123; $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");&#125;);$(\"button\").click(function()&#123; $(\"#test3\").val(\"RUNOOB\");&#125;); attr() 以下是一个点击按钮将a标签的跳转地址变为搜狗的示例 123456789101112131415&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;button&gt;按钮&lt;/button&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"a\").attr(\"href\",\"https://www.sougou.com\"); &#125;);&#125;);// 同时设置多个属性$(document).ready(function()&#123; $(\"a\").attr(&#123; \"href\" : \"https://www.sougou.com\", \"class\" : \"sougou\" &#125;);&#125;); jQuery效果显示|隐藏 hide(speed:[slow|fast], callback)：隐藏元素 show(speed:[slow|fast], callback)：显示元素 123456789101112&lt;p&gt;这是一段文字&lt;/p&gt;&lt;button id=\"hide\" &gt;hide&lt;/button&gt; &lt;button id=\"show\" &gt;show&lt;/button&gt;$(document).ready(function()&#123; $(\"#hide\").click(function()&#123; $(\"p\").hide(\"slow\"); &#125;); $(\"#show\").click(function()&#123; $(\"p\").show(); &#125;);&#125;); toggle()：显示被隐藏的元素，并隐藏已显示的元素 12345&lt;p&gt;这是一段文字&lt;/p&gt;&lt;button&gt;按钮&lt;/button&gt;$(\"button\").click(function()&#123; $(\"p\").toggle();&#125;); 淡入|淡出 fadeIn()：淡入已隐藏的元素 123456789101112&lt;p id=\"p1\"&gt;这是一段文字&lt;/p&gt;&lt;p id=\"p2\"&gt;这是一段文字&lt;/p&gt;&lt;p id=\"p3\"&gt;这是一段文字&lt;/p&gt;&lt;button&gt;按钮&lt;/button&gt;$(document).ready(function()&#123; $(\"p\").hide() // 隐藏元素 $(\"button\").click(function()&#123; $(\"#p1\").fadeIn(); $(\"#p2\").fadeIn(\"slow\"); $(\"#p3\").fadeIn(3000); &#125;);&#125;); fadeOut()：淡出可见元素 1234567891011&lt;p id=\"p1\"&gt;这是一段文字&lt;/p&gt;&lt;p id=\"p2\"&gt;这是一段文字&lt;/p&gt;&lt;p id=\"p3\"&gt;这是一段文字&lt;/p&gt;&lt;button&gt;按钮&lt;/button&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#p1\").fadeOut(); $(\"#p2\").fadeOut(\"slow\"); $(\"#p3\").fadeOut(3000); &#125;);&#125;); fadeToggle()：在fadeIn()与fadeOut()方法之间进行切换 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#p1\").fadeToggle(); $(\"#p2\").fadeToggle(\"slow\"); $(\"#p3\").fadeToggle(3000); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"p1\"&gt;这是一段文字&lt;/p&gt; &lt;p id=\"p2\"&gt;这是一段文字&lt;/p&gt; &lt;p id=\"p3\"&gt;这是一段文字&lt;/p&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 滑动12345- slideDown(speed,callback) // 向下滑动元素- slideUp(speed,callback) // 向上滑动元素- slideToggle(speed,callback) // 在 slideDown() 与 slideUp() 方法之间进行切换// 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。// 可选的 callback 参数是滑动完成后所执行的函数名称 jQuery动画 $(selector).animate( {params}, speed, callback) params：可选参数；动画形成的属性，要改变的样式值，写成字典 speed：可选参数；动画持续的时间，单位毫秒 callback：可选参数；动画完成后执行的函数名称 注意：当使用animate()时，必须使用Camel标记法书写所有的属性名；比如，必须使用paddingLeft而不是padding-left，使用 marginRight 而不是margin-right，等等、同时，色彩动画并不包含在核心jQuery 库中 12345678910111213141516&lt;p style=\"position: relative;\"&gt;这是一段文字&lt;/p&gt;&lt;button&gt;按钮&lt;/button&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").animate( &#123; left: \"+=300px\", fontSize: \"100px\", &#125;, \"slow\", function(argument) &#123; alert(\"动画完成\") &#125; ) &#125;)&#125;); jQuery获取表单数据 单选框：radio 1234$(\"input[type=radio]:checked\").val()// 当一个页面有两个radio时$(\"input[name='gender']:checked\").val(); // 通过name分类进行过滤 checked代表选中元素 多选框：checkbox 12345var res = new Array;var olike = $(\"input:checkbox[name='like']:checked\").each(function()&#123; res.push($(this).val())&#125;)// each() 方法规定为每个匹配元素规定运行的函数 下拉菜单：select 1$(\"select[name='city']\").val(); jQuery正则正则规则123456789- \\d：匹配一个数字- \\D：匹配一个非数字，即除了0-9- \\w：匹配字母、数字、下划线- \\W：匹配非单词字符，等价于\\[^A-Za-z0-9_\\]- \\s：匹配一个空白符- \\S：匹配一个非空白符- \\b：匹配单词边界- \\B：匹配非单词边界- .：匹配任意字符 开头结尾12- ^：开头匹配 - $：结尾匹配 正则次数1234- ?：出现零次或一次；最多出现一次- +：出现一次或多次；至少出现一次- *：出现零次或多次；任意次- &#123;n,m&#125;：出现n-m次 匹配范围12- [a-z]：匹配任意小写字母- [0-9]：匹配任意数字 正则语法 var regex = /规则/参数 1/\\d+/ // 匹配所有数字 创建正则表达式12345var regex = /[a-z]+$/ ; // 任意小写字母结尾var regex = new RegExp()- g：全局的匹配(匹配多次；)- i：大小写不敏感匹配(忽略字符大小写)- m：多行(^和$能匹配行结束符) 捕获型|非捕获型12(?:(\\d+)) // 非捕获型分组 结果并不会复制所匹配的文本(\\d+) // 其中的\\d+ 是捕获型分组，结果会放入最终的匹配结果中 正则判断方法 1regex.exec ：将匹配到的文本保存到一个结果数组 本身的表达式是一个包含分组匹配的，那么使用exec可以将每个分组保存到数组结果的依次位置中 regex.test：匹配成功返回true，否则返回假 常用正则规则12345678910regAccount = /^\\w&#123;6,20&#125;$/; // 字母数字下划线，用户名验证6-20位regEmail = /^[a-zA-z1-9]&#123;8,20&#125;@(163|126|qq)\\.(com|cn)$/ // 邮箱验证regPass = /^[\\w!@#$%^&amp;*]&#123;6,20&#125;$/ // 密码验证regPhone = /^1[3,4,5,7,8]\\d&#123;9&#125;$/ // 手机号验证sStr = \"123456\"regex = /\\d+/alert(regex.test(sStr)); // true AJAX $.ajax([settings])：执行ajax请求 1234567891011121314151617181920212223242526$(document).ready(function()&#123; $(\"button\").click(function()&#123; $.ajax(&#123; url: \"/ajax/\",// 发送请求的地址 type: \"POST\", // 请求方式 默认get data: &#123; // 要提交的数据 username:$(\"#username\").val(), // \"csrfmiddlewaretoken\":$(\"[name='csrfmiddlewaretoken']\").val(), // django的csrf防跨站请求伪造令牌 &#125;, beforeSend: function()&#123; // 发送请求前运行的函数 $(\"button\").attr(&#123; disabled: \"disabled\" &#125;) &#125;, success: function(result)&#123; // 请求成功后的回调函数 // 服务器返回根据datatype设定的类型数据 $(\"#result\").text(result) console.log(result) &#125;, complete: function()&#123; // 请求完成时运行的函数 // 在请求成功或失败之后均调用，即在 success 和 error 函数之后 $(\"button\").removeAttr(\"disabled\"); &#125;, &#125;) &#125;);&#125;); django服务端的功能： 123456789# views.pydef ajax(request): if request.is_ajax(): # 判断是否是ajax请求 print(request.POST) print(request.body) username = request.POST.get(\"username\") #获取ajax传递来的数据中的 username对应的数据 return HttpResponse(json.dumps(\"这是我获取到的:%s\" % (username,))) response = render(request,\"ajax.html\") return response 关于ajax与django等服务端后台进行通信的示例还在后头儿，敬请期待","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2019-10-21T02:51:45.043Z","updated":"2019-10-21T02:52:45.093Z","comments":true,"path":"2019/10/21/JavaScript/","link":"","permalink":"http://laxe.top/2019/10/21/JavaScript/","excerpt":"JavaScript JavaScript是运行在浏览器端的脚本语言，JavaScript主要解决的是前端与用户交互的问题 是一种动态性、弱类型的语言； 他的解释器就在我们的浏览器中，是浏览器的一部分 这门语言对大小写敏感，并会忽略多余的空格，可以使用\\进行代码换行，注释使用//或/**/","text":"JavaScript JavaScript是运行在浏览器端的脚本语言，JavaScript主要解决的是前端与用户交互的问题 是一种动态性、弱类型的语言； 他的解释器就在我们的浏览器中，是浏览器的一部分 这门语言对大小写敏感，并会忽略多余的空格，可以使用\\进行代码换行，注释使用//或/**/ 主要由三部分组成 ECMAScript：语言的语法和基本对象 文档对象模型Dom(Document Object Model)：处理网页内容的方法和接口 浏览器对象模型Bom(BrowserObjectModel)：与浏览器进行交互的方法和接口 前端三大部 HTML：页面的内容、结构 CSS：页面的表现形式、部分动画 JavaScript：页面的行为、交互、功能 JavaScript引入 行间事件：为某一个具体的元素标签赋予js内容 1&lt;input type=\"button\" value=\"按钮\" onclick=\"alert('点我');\"&gt; 嵌入引入：在文档页面通过Script标签嵌入 123456&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; alert(\"ok!\"); &lt;/script&gt;&lt;/head&gt; 外部引入：定义单独js文件，通过script标签进行引入 1&lt;script type=\"text/javascript\" src=\"js/main.js\"&gt;&lt;/script&gt; alert函数用来展示一个提示框 变量定义 123var x = 1var y = \"2\"var z = 2 定义变量需要使用关键字：var 同时定义多个变量可以使用 ， 隔开 注意：javascript变量均为对象，每当声明一个变量，就相当于创建了一个对象 命名规则： 区分大小写 首字符为字母、数字、下划线_、或美元符号$ 其他字符可以为字母、数字、下划线、美元符号 调试程序的方法： alert：弹框 console.log()：浏览器控制台 document.title()：页面标题 基本数据类型 Number：数字类型，可以带小数点，也可以不带 12var a = 1;var b = 1.5; String：字符串类型，可以使用单引号或双引号 12var a = \"abc\";var b = \"aaaa\" + 1 Boolean：布尔类型，只能是true|false 1var a = true; undefined：未定义类型 1var a; null：空对象类型 1var a = null; 查看变量数据类型 12var x = \"abc\";alert(typeof x) 匈牙利命名规则： 对象 o (Object)：oPerson 数组 a (Array)：aUsers 字符串 s (String)：sAccount 整数 i (Integer)：iScore 布尔值 b (Boolean)：bIsLogin 浮点数 f (Float)：fPrice 函数 f (Function)：fEats 正则 re (RegExp)：reIDCard 类型转换 转换为字符串：toString，支持Boolean、Number、String三种主要类型 123456var x = 1;var y = \"abc\";var z = true;alert(x.toString()) // \"1\"alert(y.toString()) // \"abc\"alert(z.toString()) // \"true\" 转换为数字：parseInt、parseFloat，将只含有数字的字符串变为整形或浮点型，其他类型返回NaN() 123456789var x = \"123\"var y = \"123.01\"var z = \"123aa\"alert(parseInt(x)) // 123alert(parseFloat(x)) // 123alert(parseInt(y)) // 123alert(parseFloat(y)) // 123.01alert(parseInt(z)) // 123alert(parseFloat(z)) // 123 注意：parseFloat转换的包含浮点数的字符串应该是十进制 八进制或十六进制，该方法会忽略前导0 八进制数字020会被解析为20 十六进制数字0xFF，会返回Nan，因为x符号不是有效字符 强制类型转换 Boolean()：当要转换的值是至少有一个字符的字符串 非0数字或对象时，Boolean()函数将返回true 如果该值是空字符串、数字0、undefined或null，它将返回false。 1234alert(Boolean(0)) // falsealert(Boolean(1)) // truealert(Boolean(\"1\")) // truealert(Boolean(\"1a\")) // true Number()：换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值 123456789alert(Number(false)) // 0alert(Number(true)) // 1alert(Number(undefined)) // NaNalert(Number(null)) // 0alert(Number(\"1.2\")) // 1.2alert(Number(\"12\")) // 12alert(Number(\"1.2.3\")) // NaNalert(Number(new object())) // NaNalert(Number(50)) // 50 String()：可把任何值转换成字符串 注意：强制转换成字符串和调用toString()方法的唯一不同之处在于，对null和undefined值强制类型转换可以生成字符串而不引发错误 复合类型 Array：数组，索引从0开始 123456var people = ['张三','李四','王五'];var people = new Array('张三','李四','王五');var people = new Array();people[0] = \"张三\"people[1] = \"李四\"people[2] = \"王五\" Object：对象，就像是字典，定义时key值不需要设置类型 1234567891011var person = &#123; name: \"张三\", age: 18, sex: \"male\",&#125;;/*对象有两种访问方式：*/person[\"name\"]person.namevar person = new Object();person.name = \"张三\";person.age = 17; 函数 函数语法：包裹在花括号中的代码块，前面使用了关键词function 12345678910&lt;button onclick=\"func()\"&gt;点击这里&lt;/button&gt;function func(arg1,arg2,...) &#123; alert(\"函数被执行\") // 执行代码 return 1; // return是可选的，并且可以不写返回值，单纯只做函数终止&#125;// 函数名 func// 参数 arg1,arg2,...// 返回值 return 1func() // 函数执行 变量作用域 局部变量 在JavaScript函数内部声明的变量（使用var）是局部变量， 只能在函数内部访问它 该变量的作用域是局部的 生命周期：局部变量会在函数运行以后被删除 (生命期从它们被声明的时间开始) 全局变量 在函数外声明的变量是全局变量 网页上的所有脚本和函数都能访问它 生命周期：全局变量会在页面关闭后被删除 (生命期从它们被声明的时间开始) 局部变量如果希望变为全局变量、可以使用windows.var =的形式赋予给当前窗口 12var x = 1;window.x = x; 12345function func(x,y)&#123; return x + y&#125;var res = func(1,2)alert(res) 1JavaScript 函数解析过程： 预编译：function函数提前，并将var定义的变量声明提前，先暂时赋值为undefined 执行 1234567func() // 弹出提示alert(iNum) // undefinedalert(abc) // 出错function func() &#123; alert(\"这个是函数\")&#125;var iNum = 1 匿名函数 函数可以没有名字，比如直接为某些事件赋值 1234window.onload = function()&#123; var sDate = new Date() console.log(sDate)&#125; 封闭函数 封闭函数常用来创建一个开始就执行而不用命名的函数 123(function()&#123; alert(\"你好\");&#125;)(); 也可以在函数定义前加上”~“和”!“等符号来定义匿名函数 123!function()&#123; alert(\"你好\");&#125;(); 封闭函数可以创建一个独立的空间，在封闭函数内定义的变量不会影响外部同名的函数和变量，可以避免命名冲突 123456var x = 1;!function()&#123; var x = \"这是同名变量\"; alert(x);&#125;alert(x); 当页面上引入多个js文件时，用这种办法比较安全 运算算术运算符 运算符 描述 示例 结果 + 加 x=y+2 x=7 - 减 x=y-2 x=3 * 乘 x=y*2 x=10 / 除 x=y/2 x=2.5 % 取余 x=y%2 x=1 ++ 累加 x=++y x=6 -- 递减 x=--y x=4 赋值运算符 运算符 例子 等价于 结果 = x=y x=5 += x+=y x=x+y x=15 -= x-=y x=x-y x=5 *= x*=y x=x*y x=50 /= x/=y x=x/y x=2 %= x%=y x=x%y x=0 注意：数字与字符串相加，结果将成为字符串 比较运算符 运算符 描述 示例 == 等于 x==8为false === 全等（值和类型） x===5为true；x===&quot;5&quot;为false != 不等于 x!=8为true &gt; 大于 x&gt;8为false &lt; 小于 x&lt;8为true &gt;= 大于或等于 x&gt;=8为false &lt;= 小于或等于 x&lt;=8为true 比较运算符常在条件语句中进行使用 1234var name = \"张三\"; if (name==\"张三\") &#123; document.write(\"这个人是张三\") &#125; 逻辑运算符 运算符 描述 示例 &amp;&amp; and (x &lt; 10 &amp;&amp; y &gt; 1) 为 true ` ` ! not !(x==y) 为 true 条件运算符12var NumCheck = 0; var Dis = (NumCheck==0) ? \"是数字0\":\"不是数字0\"; 如果变量NumCheck是0，则Dis的值为：”是数字0“；反之为：”不是数字0“ 条件语句 条件语句 12345678var iNum = 0;if (iNum==0)&#123; ...;&#125;else if (iNum==1) &#123; 条件细分...;&#125;else&#123; 不满足以上条件均到这里; &#125; switch语句 1234567891011var day = new Date().getDay();// 星期日:0 范围:0~6switch(day)&#123; case 0: alert(\"今天是星期二\"); break; case 1: ... break; ...&#125; 工作原理：首先设置表达式n（通常是一个变量）；随后表达式的值会与结构中的每个case的值做比较。如果存在匹配，则与该case关联的代码块会被执行。请使用break来阻止代码自动地向下一个case运行 for循环语句 语法 12345678910111213141516171819202122for(var i = 0; i &lt; len; i++)&#123; ...&#125;// for(起点数据; 判断条件; 数据递增或递减)&#123;&#125;var i = 0;for( ;i &lt; 10; i++)&#123; ...&#125;// 如果循环起始值已经被设置，可以在开头省略for(var i = 0; ; i++)&#123; ... if (i==5)&#123; ... break; //终止循环 &#125;&#125;// 当没有第二个语句时，必须在循环内提供break，否则循环则无法停下来，可能令浏览器崩溃for(var i = 0; i &lt; 10; )&#123; console.log(i); i += 2;&#125;// 如果没有提供第三个语句，可以在for循环中进行编写数值的变化 for/in语句循环遍历对象的属性 12345678910111213141516for (x in object)&#123; console.log(x);&#125;// 字符串：x 取下标// 数组：x 取下标// 对象：x 取keyvar x = \"abcdef\" // 0,1,2,3,4,5var y = [1,2,3,4,\"5\"] // 0,1,2,3,4var z = &#123; // name,age,gender name:\"张三\", age:16, gender:\"male\",&#125;for (obj in z)&#123; console.log(obj);&#125; while循环语句 语法 12345678910while (条件)&#123; 执行代码;&#125;var x = \"abcdef\";var i = 0;while (x[i])&#123; console.log(x[i]); i++;&#125;// 下表超出范围时不会报错，返回undefined do/while循环：do/while循环是while循环的变体 该循环首先会执行一次循环代码块，然后检查循环条件是否为真 如果条件为真，就会重复这个循环 123456789do&#123; 循环执行代码&#125;while (条件);var i = 3;do&#123; console.log(i) i--;&#125;while (i &gt; 5);// do/while循环至少会执行一次 获取页面元素 通过页面元素ID值进行获取：document.getElementById(&#39;&#39;) 获取到的是一个HTML对象，可以赋值给一个变量 注意：获取对应元素时，首先要确定页面已经生成所需元素 通常我们将javascript代码写到页面最下面 或通过使用windows.onload()事件判断是否已经生成页面 123456789101112131415161718192021&lt;body&gt; &lt;p id=\"p\"&gt;这是一段待获取的文字&lt;/p&gt; &lt;script&gt; function func()&#123; var sP = document.getElementById('p'); console.log(sP); &#125; func() &lt;/script&gt;&lt;/body&gt;&lt;!-- 获取到的内容: &lt;p id=\"p\"&gt;这是一段待获取的文字&lt;/p&gt; --&gt;&lt;body&gt; &lt;p id=\"p\"&gt;这是一段待获取的文字&lt;/p&gt; &lt;script&gt; window.onload = function()&#123; var sP = document.getElementById('p'); console.log(sP); &#125; &lt;/script&gt;&lt;/body&gt;&lt;!-- 获取到的内容: &lt;p id=\"p\"&gt;这是一段待获取的文字&lt;/p&gt; --&gt; 操作页面元素 可以通过id方式获取到对应页面内的元素，就可以对元素的属性进行操作，包括对属性的读和写 读取元素属性：元素.属性 12345678&lt;p id=\"aaa\" style=\"color: red;\"&gt;这是一段待获取的文字&lt;/p&gt;&lt;script&gt; var oP = document.getElementById('aaa'); console.log(oP) console.log(oP.id); console.log(oP.style); console.log(oP.style.color);&lt;/script&gt; 修改元素属性：元素.属性 =xxx 1234567891011121314151617181920&lt;p id=\"aaa\" style=\"color: red;\"&gt;这是一段待获取的文字&lt;/p&gt;&lt;button onclick=\"blue_font()\"&gt;按钮&lt;/button&gt;&lt;script&gt; function blue_font()&#123; var oP = document.getElementById('aaa'); oP.style.color = \"blue\"; // 修改字体样式属性中的字体颜色为蓝色 &#125;&lt;/script&gt;&lt;p id=\"aaa\" style=\"color: red;\"&gt;这是一段待获取的文字&lt;/p&gt;&lt;button id=\"color_button\"&gt;按钮&lt;/button&gt;&lt;script&gt; color_button.onclick = function()&#123; var oP = document.getElementById('aaa'); oP.style.color = \"blue\"; // 修改字体样式属性中的字体颜色为蓝色 &#125;&lt;/script&gt; 也可以获取到对应按钮元素后在绑定函数到它 12345678910&lt;p id=\"aaa\" style=\"color: red;\"&gt;这是一段待获取的文字&lt;/p&gt;&lt;button id=\"Button\"&gt;按钮&lt;/button&gt;&lt;script&gt; var oButton = document.getElementById('Button'); oButton.onclick = function()&#123; var oP = document.getElementById('aaa'); oP.style.color = \"blue\"; // 修改字体样式属性中的字体颜色为蓝色 &#125;&lt;/script&gt; 读取或写入标签包裹的内容（读取或修改标签文本内容）：innerHTML 12345678910&lt;a id=\"a\" href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;button onclick=\"urlChange()\"&gt;变搜狗&lt;/button&gt;&lt;script&gt; function urlChange()&#123; var oA = document.getElementById('a'); oA.href = \"https://www.sougou.com\"; console.log(oA.innerHTML); // 获取标签文本内容 oA.innerHTML = \"搜狗\"; //修改标签文本内容 &#125;&lt;/script&gt; JS事件及属性 常见事件 1234567- 用户点击鼠标- 网页已加载- 图像已加载- 鼠标移动某个元素上- 输入字段被改变时- 提交表单时- 用户触发某些按键时 onclick事件：用户点击鼠标 12345678910111213141516&lt;p onclick=\"TextChange(this)\"&gt;这是文本&lt;/p&gt;&lt;!-- this 代表当前所处的元素 --&gt;&lt;script&gt; function TextChange(id)&#123; id.innerHTML = \"文本修改\"//可以直接通过传来的参数进行页面元素的读取及修改 &#125;&lt;/script&gt;&lt;p id=\"p\"&gt;这是文本&lt;/p&gt;&lt;script&gt; var oP = document.getElementById(\"p\"); oP.onclick = function()&#123; oP.innerHTML = \"文本修改\"//可以直接通过传来的参数进行页面元素的读取及修改 &#125;&lt;/script&gt; onmouseover事件：鼠标移入 onmouseout事件：鼠标移出 12345678910&lt;p id=\"aaa\"&gt;请把鼠标移动过来&lt;/p&gt;&lt;script&gt; var oP = document.getElementById(\"aaa\"); oP.onmouseover = function()&#123; oP.style.color = \"green\";//可以直接通过传来的参数进行页面元素的读取及修改 &#125; oP.onmouseout = function()&#123; oP.style.color = \"red\"; &#125;&lt;/script&gt; JS高级字符串及操作方法 字符串合并：+ 数字字符串变整数：parseInt() 数字字符串变浮点数：parseFloat() 字符串按分隔符切分：split(&quot;*&quot;) 123var x = \"a*b*c*d\"alert(x.split(\"*\")) // a,b,c,dconsole.log(x.split(\"*\")) // [\"a\", \"b\", \"c\", \"d\"] 查找字符串是否含有某字符，找到返回索引，找不到返回-1：String.indexOf() 123var x = \"abcdefag\"var res = x.indexOf(\"z\")alert(res) 截取字符串：String.substring(start, end)，不包含end索引位置数据 1234var x = \"abcdefag\"alert(x.substring(2)) // cdefagalert(x.substring(2,4)) // cdalert(x.substring()) // abcdefag 字符串反转：通过结合数组的reverse()函数 12var x = \"abcd\";console.log(x.split(\"\").reverse().join(\"\")) //dcba 数组及操作方法 定义数组的方法 12345var aList = new Array(1,2,3);var aList = new Array();aList[0] = \"a\";aList[1] = \"b\";var aList = [1,2,3,4,\"a\"]; 获取数组的长度：Array.length() 12var aList = new Array(1,2,3);console.log(aList.length) // 3 将数组成员通过指定拼接符合并成一个字符串：Array.join(&quot;*&quot;) 12var aList = [1,2,3,4,5]console.log(aList.join(\"*\")) // 1*2*3*4*5 向数组的最后增加或删除成员：Array.pop()、Array.push() 123456var aList = [1,2,3,4,5]var opa = aList.pop() // opa: 5console.log(opa) // 5console.log(aList) // [1, 2, 3, 4]aList.push(\"a\")console.log(aList) // [1, 2, 3, 4, \"a\"] 将数组反转：Array.reverse() 123var aList = [1,2,3,4,5];aList.reverse();console.log(aList); //[5, 4, 3, 2, 1] 返回数组中元素第一次出现的索引值：Array.indexOf(chr) 12var aList = [1,2,3,4,5];console.log(aList.indexOf(3)) // 2 在数组中增加或删除成员，并返回被删除的：Array.splice(index, howmany, items...) 从index位置开始，给定的hwomany个数的值，并用后面的items替换这些被删除的值 123var aList = [1,2,\"a\",4,5]aList.splice(2,1,\"b\",\"c\")console.log(aList) // [1, 2, \"b\", \"c\", 4, 5] 多维数组 数组的成员包含数组 123var aList = [1,2,3,[\"a\",\"b\"]]console.log(aList[-1][0]) // 出错 undefinedconsole.log(aList[3][0]) // a 定时器 作用：定时调用函数、制作动画 反复执行定时器 setInterval(code, millisec)：反复执行的定时器 code: 必须参数，要调用的函数或要执行的代码串 millisec: 必须参数，执行code任务所需要的事件间隔，以毫秒计 clearInterval(setInterval_obj)：关闭反复执行的定时器 12345678910111213141516171819&lt;!--跑马灯效果--&gt;&lt;h3 id=\"h3\"&gt;abcdefg&lt;/h3&gt;&lt;button id=\"start_button\"&gt;开始&lt;/button&gt;&lt;button id=\"stop_button\"&gt;停止&lt;/button&gt;&lt;script&gt; start_button.onclick = function()&#123; // 开启定时事件 var sT = setInterval(loop,1000); window.sT = sT; // 声明此sT定时事件为全局变量 &#125; stop_button.onclick = function()&#123; // 关闭定时事件 clearInterval(sT) &#125; function loop()&#123; var Opstr = document.getElementById('h3'); Opstr.innerHTML = Opstr.innerHTML.substring(1) + Opstr.innerHTML[0] console.log(Opstr.innerHTML) &#125;&lt;/script&gt; 等待执行定时器 setTimeout(code, millisec)：定义只执行一次的等待定时器 1code : 必须参数，要调用的函数或要执行的代码串 millisec: 必须参数，执行code任务所需要的事件间隔，以毫秒计 clearTimeout(setTimeout_obj)：关闭只执行一次的等待计时器 123456789101112&lt;h3 id=\"h3\"&gt;我是一个内容&lt;/h3&gt;&lt;button id=\"start_button\"&gt;让上面的内容消失&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; start_button.onclick = function()&#123; var st = setTimeout(clear,1000) window.st = st; &#125; function clear()&#123; var oH3 = document.getElementById('h3'); oH3.innerHTML = \"\"; &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Css","slug":"Css","date":"2019-10-21T02:49:45.661Z","updated":"2019-10-21T02:51:18.064Z","comments":true,"path":"2019/10/21/Css/","link":"","permalink":"http://laxe.top/2019/10/21/Css/","excerpt":"CSS CSS值层叠样式表（Cascading Style Sheets），主要为了让我们的HTML页面具有花里胡哨的样式效果 样式定义如何显示HTML元素 样式通常存储在样式表中 外部样式表可以极大的提高工作效率 外部样式表通常存储后缀为CSS的文件中 多个样式定义可层叠为一","text":"CSS CSS值层叠样式表（Cascading Style Sheets），主要为了让我们的HTML页面具有花里胡哨的样式效果 样式定义如何显示HTML元素 样式通常存储在样式表中 外部样式表可以极大的提高工作效率 外部样式表通常存储后缀为CSS的文件中 多个样式定义可层叠为一 有了CSS，html中大部分表现样式的标签就可以不用了 html只负责文档的结构和内容，表现形式完全交给CSS，html文档变得更加简洁 CSS的引入方式 内联式引入：直接赋予标签style属性进行样式编写 1&lt;body style=\"background: #00ff00\"&gt; 嵌入式：直接在文档页面通过style标签创建嵌入的样式表 12345&lt;style type=\"text/css\"&gt; body&#123; background: black; &#125;&lt;/style&gt; 外部式：在文档中通过link标签，将外部样式文件引入到页面中： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\"&gt; 优先级：内联式 &gt; 嵌入式 &gt; 外部式 （就近原则） CSS语法 CSS语法规则由两部分构成：选择器 &amp; 一条或多条声明 1234selector&#123; declaration1; declaration2;&#125; selector：选择器，一般是你需要改变的HTML标签declaration1：每条声明，由一个属性和一个值组成 123selector&#123; property: value;&#125; 属性（property）是您希望设置的样式属性（style attribute） 每个属性有一个值；属性和值被冒号分开 当属性中的值为若干单词时，加引号 123h1&#123; font-family: \"sans serif\";&#125; 颜色的写法： 12345678910p&#123; color: #00FF00;&#125;h1&#123; color: #0F0&#125;body&#123; background: rgb(255,0,0); background: rgb(100%,0%,0%);&#125; 请注意，当使用RGB百分比时，即使当值为0时也要写百分比符号当尺寸为0像素时，0之后不需要使用px单位，因为0就是0，无论单位是什么 CSS选择器标签选择器 影响范围大，常做通用设置，或用在层级选择器中 123456&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;再来一段&lt;/p&gt;p&#123; color: blue;&#125;/*定义所有p标签字体为蓝色*/ 类选择器 通过类名来选择元素，一个类可以用于多个元素 一个元素也可以使用多个类，应用灵活，可复用 是CSS中使用最多的一种选择器 注意：类名的第一个字符不能使用数字 12345678910&lt;p class=\"big\"&gt;第一段文字&lt;/p&gt;&lt;p class=\"big red\"&gt;再来一段&lt;/p&gt;.big&#123; font-size: 20px&#125;/*定义big类字体大小为20像素*/.red&#123; color: red;&#125;/*定义类为red的字体颜色为红色*/ 类选择器还可基于所属标签进行派生选择： 12345678&lt;p class=\"red\"&gt;再来一段&lt;/p&gt;&lt;div class=\"red\"&gt; 文字测试&lt;/div&gt;div.red&#123; color: red;&#125;/*在页面中只有div类为red的字体颜色会变为红色*/ 属性选择器 对指定属性的HTML元素进行设置，而不限于class和id属性 通过属性 123456&lt;a href=\"https://www.baidu.com\"&gt;这是一个连接&lt;/a&gt;&lt;p href=\"test\"&gt;测试&lt;/p&gt;[href]&#123; color: blue;&#125;/*为所有具有href属性的元素设置字体颜色*/ 通过属性的值（整个匹配） 123456&lt;a href=\"https://www.baidu.com\"&gt;这是一个连接&lt;/a&gt;&lt;p href=\"test\"&gt;测试&lt;/p&gt;[href=\"test\"]&#123; font-size: 20px;&#125;/*为属性为test的元素设置字体大小*/ 属性的值（属性的值中包含所匹配的单词）：~= 12345678&lt;p attr=\"test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"test-xx\"&gt;测试&lt;/p&gt; x&lt;p attr=\"test_xx\"&gt;测试&lt;/p&gt; x&lt;p attr=\"test xx\"&gt;测试&lt;/p&gt; √[attr~=test]&#123; font-size: 20px;&#125;/*为属性包含test的元素设置字体大小*/ 注意：不包含下划线和连字符的 属性的值（从开头整个匹配或带有连字符的属性值）：|= 12345678&lt;p attr=\"test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"test-xx\"&gt;测试&lt;/p&gt; √&lt;p attr=\"test_xx\"&gt;测试&lt;/p&gt; x&lt;p attr=\"test xx\"&gt;测试&lt;/p&gt; x[attr|=test]&#123; font-size: 20px;&#125;/*为单词为test或开头为test-的元素设置字体大小*/ 注意：适用于由连字符分隔的属性值 属性的值（从属性值的开头进行匹配）：^= 12345678&lt;p attr=\"test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"test-xx\"&gt;测试&lt;/p&gt; √&lt;p attr=\"test_xx\"&gt;测试&lt;/p&gt; √&lt;p attr=\"test xx\"&gt;测试&lt;/p&gt; √[attr^=test]&#123; font-size: 20px;&#125;/*为开头包含test的所有元素设置字体大小*/ 属性的值（从属性值的结尾开始匹配）：$= 12345678&lt;p attr=\"test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"xx-test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"xx_test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"xx test\"&gt;测试&lt;/p&gt; √[attr$=test]&#123; font-size: 20px;&#125;/*为结尾是test的所有元素设置字体大小*/ 属性的值（只要含有则匹配）：*= 12345678&lt;p attr=\"test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"xx-test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"xx_test\"&gt;测试&lt;/p&gt; √&lt;p attr=\"xx test\"&gt;测试&lt;/p&gt; √[attr*=test]&#123; font-size: 20px;&#125;/*为含有test的所有元素设置字体大小*/ 几种属性选择的匹配方式 1~= ：用于选取属性值中包含指定 词汇 的元素； 必须是单独的词汇，不能是带有连字符或下划线组成的单词。 1|= ：用于选取带有以指定值开头的属性值的元素，该值必须是整个单词； 可以有连字符组成，word或者是word-wild ^=：匹配属性值以指定值开头的每个元素 $=：匹配属性值以指定值结尾的每个元素 *=：匹配属性值中包含指定值的每个元素 层级选择器 主要应用在标签嵌套的结构中，通过层级，限制样式的作用范围 1234567891011121314151617181920212223242526272829&lt;div class=\"header\"&gt; &lt;p class=\"title\"&gt;标题1&lt;/p&gt; &lt;span class=\"author\"&gt;作者1&lt;/span&gt; &lt;p class=\"content\"&gt; 主要内容 &lt;/p&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt; &lt;p class=\"title\"&gt;标题2&lt;/p&gt; &lt;span class=\"author\"&gt;作者2&lt;/span&gt; &lt;p class=\"content\"&gt; 主要内容2 &lt;/p&gt;&lt;/div&gt;.header .title&#123; color: gold; font-size: 30px;&#125;/*生效所有header类下的title类*/.header .author&#123; color: blue; font-size: 15;&#125;/*生效所有header类下的author类*/.header p&#123; font-weight: bold;&#125;/*生效所有header类中的p标签*/ ID选择器 通过ID名进行元素选择，元素的ID名定义时在整个文档属于唯一 通过ID选择器只能对应页面元素中的一个 ID名通常作为JS脚本定位使用，不推荐ID选择器 1234567891011121314151617&lt;div class=\"header\"&gt; &lt;p id=\"title\"&gt;标题1&lt;/p&gt; &lt;span id=\"author\"&gt;作者1&lt;/span&gt; &lt;p id=\"content\"&gt; 主要内容 &lt;/p&gt;&lt;/div&gt;#title&#123; font-size: 25px; font-weight: bold;&#125;#author&#123; font-size: 10px;&#125;#content&#123; color: blue;&#125; 伪类选择器 CSS伪类选择器用于向某些选择器添加特殊的效果 伪类的语法 123selector:pseudo-class&#123; property: value;&#125; 与css类搭配使用 123selector.class:pseudo-class&#123; property: value;&#125; 锚伪类 控制连接访问状态，常见状态有：活动状态、已访问状态、未被访问状态、鼠标悬停状态 1234567891011121314151617&lt;a class=\"baidu\" href=\"https://www.baidu.com\"&gt;访问这里&lt;/a&gt;.baidu:link&#123; color: blue;&#125;/*未访问过的连接*/.baidu:visited&#123; color: black;&#125;/*访问过的连接*/.baidu:hover&#123; color: gold;&#125;/*鼠标划过的连接*/.baidu:active&#123; color: red;&#125;/*已选中的连接*/ link、visited、hover、active 注意 hover必须定义在link和visited之后，才是有效的 active必须定义在hover之后，才是有效的 CSS选择器的权重 当有多个同类样式作用于同一个元素时 权重高的样式对元素起作用 权重相同时后写的样式覆盖前面写的 使用!important将样式权重设置为10000，将!important写到样式属性值后 权重值：就近原则 内联式样式：1000 1&lt;p style=\"color: red;\"&gt;&lt;/p&gt; ID选择器：100 1#id &#123;color: red;&#125; 类选择器：10 1.class &#123; background: blue;&#125; 标签选择器：1 1p&#123;font-weight:bold;&#125; 1234&lt;p id=\"test\" style=\"color: blue;\"&gt;测试&lt;/p&gt;#test&#123; color: red !important;&#125; CSS基本属性布局属性 width：设置元素（标签）的宽 height：设置元素（标签）的高 1#button&#123;width:100px; height:100px;&#125; background：设置背景色或背景图 12345body&#123; width: 100%; height: 100%; background: #00FF00 url(\"../img/1.jpg\") no-repeat ;&#125; background属性可以分解为如下几个设置项： background-color：设置背景颜色 background-image：设置背景图片地址 background-repeat：设置图片如何重复平铺，可选参数有：repeat、repeat-x（水平方向重复）、repeat-y（垂直方向重复）、no-repeat（图片只显示一次） 12&gt; background-position`：设置图片的位置，可选参数有：`left`、`right`、`center&gt; background-attachment：设置图片是固定的还是会随页面滚动，可选参数有：scroll（背景图片会随着页面其余部分的滚动而移动）、fixed（页面的其余部分滚动时，背景图像不会移动） 注意：在背景图片路径填写时，如果使用内联式写法则从当前页面路径开始查找相对路径，如写在外部CSS文件中，则以CSS文件为相对基础。 border：设置元素周围的边框 123p&#123; border: 10px double blue;&#125; 依次设置：border-width、border-style、border-color 也可以拆分成四个边的样式选项 border-top：顶边框 border-buttom：底边框 border-left：左边框 border-right：右边框 123456[attr]&#123; border-top: 5px inset blue; border-bottom: 5px inset green; border-left: 5px outset red; border-right: 5px outset red;&#125; 设置时提供的边框样式属性 dotted：点状 solid：实线 double：双线 dashed：虚线 groove：3D凹槽边框 ridge：定义3D垄状边框 inset：定义3D inset 边框 outset：定义3D outset边框 inherit：规定应该从父元素继承边框样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;p class=\"p1\"&gt;aaaaaaa&lt;/p&gt;&lt;p class=\"p2\"&gt;bbbbbbb&lt;/p&gt;&lt;p class=\"p3\"&gt;ccccccc&lt;/p&gt;&lt;p class=\"p4\"&gt;ddddddd&lt;/p&gt;&lt;p class=\"p5\"&gt;ggggggg&lt;/p&gt;&lt;p class=\"p6\"&gt;eeeeeee&lt;/p&gt;&lt;p class=\"p7\"&gt;fffffff&lt;/p&gt;&lt;table class=\"table1\" border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年纪&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;.p1&#123; border: 1px dotted blue;&#125;.p2&#123; border: 1px solid blue;&#125;.p3&#123; border: 1px double blue;&#125;.p4&#123; border: 1px dashed blue;&#125;.p5&#123; border: 10px groove green;&#125;.p6&#123; border: 10px ridge blue;&#125;.p7&#123; border: 10px inset blue;&#125;.table1&#123; border: 5px double red;&#125; padding：设置元素包含的内容和元素边框的距离，也叫内边距 1234p&#123; padding: 100px; border: 1px solid black;&#125; 这个样式属性也可以拆分成以下单独四种，可以分别设置对应位置的内边距 1padding-top ：设置上内边距 padding-bottom：设置下内边距 padding-left：设置左内边距 padding-right：设置右内边距 margin：设置元素和外界的边距，也叫外边距 1234p&#123; margin: 10px;&#125;/*同时设置四个边距为10px*/ 与padding类似，margin属性也可以拆分为四个方向的单独设置 margin-top：设置上外边距 margin-bottom：设置下外边距 margin-left：设置左外边距 margin-right：设置右外边距 float：定义元素在当前父元素下向哪个方向浮动，这个属性常用于图像，使文本围绕在图像周围 如果浮动方向空间不足，元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止 1234&lt;input type=\"submit\" value=\"提交\"&gt;input&#123; float: left;&#125; 文本常用属性 color：设置元素中的文字颜色 1p&#123;color: red;&#125; font-size：设置元素中的文字大小 1p&#123;font-size: 12px;&#125; font-family：设置元素中的文字字体 123p&#123;font-family:\"微软雅黑\"&#125;/*为了避免中文兼容问题，常用字体的英文标识*/p&#123;font-family:\"Microsoft Yahei\"&#125; font-widght：设置元素中的文字是否加粗 1234p&#123;font-widght:bold;&#125;/*设置加粗*/p&#123;font-widght:normal;&#125;/*设置不加粗*/ line-height：设置元素中的文字行高 1p&#123;line-height:24px;&#125; text-decoration ：设置元素中文字的 下划线 1p&#123;text-decoration:underline;&#125; none：默认文本格式，无下划线 underline：定义文本下的一条线 overline：定义文本上的一条线 line-through：定义穿过文本的一条线 blink：定义闪烁的文本 inherit：规定应该从父元素继承text-decoration属性的值 text-align：设置元素中文字对齐方式 1p&#123;text-align:center;&#125; text-indent：设置元素中文字的首行缩进 1p&#123;text-indent:24px;&#125; display：设置元素的类型及隐藏方式 1p&#123;display:none;&#125; none： 元素不会显示 block：元素将显示为块级元素，此元素前后会带有换行符 inline：此元素被显示为内联元素，元素前后没有换行符 list-item：元素作为列表显示 table：元素作为块级表格来显示（类似 ），表格前后带有换行符 inline-table：元素作为内联表格来显示（类似 ），表格前后没有换行符 table-cell：此元素会作为一个表格单元格显示（类似 和 ） table-caption：此元素会作为一个表格标题显示（类似 ） 元素溢出 overflow：当子元素的大小超过所承载的父元素大小时，需要设置父元素对于溢出的子元素显示方式 1234567&lt;p&gt;123456789&lt;/p&gt;p&#123; width:500px; text-indent: 498px; border: 1px solid blue; overflow:auto;&#125; visible：默认值;内容不会被修剪，会呈现在元素框之外 hidden：内容会被修剪，并且其余内容是不可见的 scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容 auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容 盒子模型 使用浏览器F12查看元素 定位 文档流：文档流，是指盒子按照html标签编写的顺序依次从上到下，从左到右排列，块元素占一行，行内元素在一行之内从左到右排列，先写的先排列，后写的排在后面，每个盒子都占据自己的位置。 CSS3主要有三种定位：普通流、浮动、绝对定位 static：元素框正常生成，块级元素生成一个矩形框、作为文档流的一部分、行内元素则会创建一个或多个行框，置于其父元素中 relative：相对定位元素，元素还会保持定位前的形状，并且移动前的位置也会保留下来，不会脱离文档流 一般是将父级设置相对定位（relative），子级设置绝对定位（absolute），子级就以父级作为参照来定位，否则子级相对于body来定位 相对定位会按照元素的原始位置对该元素进行移动 absolute：绝对定位元素，元素脱离文档流，移动前的位置在文档流中关闭，定位后生成一个新的块级框，不论他之前在原始文档流中生成何种类型的框 也可以理解为漂流在文档流的上方，相对于上一个设置了定位的父级元素来进行定位，如果找不到，则相对于body元素进行定位 通过绝对定位，元素可以放置到页面上的任何位置 fixed：固定定位元素，元素脱离文档流，不占据文档流的位置，相对于浏览器窗口进行定位 元素偏移的设置： top：定位元素的上外边距边界与其包含块上边界之间的偏移 bottom：定位元素下外边距边界与其包含块下边界之间的偏移 right：定位元素右外边距边界与其包含块下边界之间的偏移 left：定位元素左外边距边界与其包含块下边界之间的偏移 z-index：设置堆叠元素的层级，这里的层级不是从上到下，而是从里到外 来一个小例子看看布局的效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051body&#123; padding: 0px; margin: 0px;&#125;.container&#123; position: relative; width: 100%; height: 100%; background: black; margin: 0px;&#125;.top&#123; position: relative; width: 100%; height: 20%; background: yellow;&#125;.left&#123; width: 20%; height: 70%; background: green;&#125;.right&#123; position: absolute; top: 20%; left: 30%; width: 70%; height: 70%; background: red;&#125;.bottom&#123; position: absolute; top: 90%; width: 100%; height: 10%; background: white;&#125;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"top\"&gt;头部&lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;div class=\"bottom\"&gt;底部&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里的例子可以将页面简单的分成四个部分","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Html","slug":"Html","date":"2019-10-21T02:47:06.598Z","updated":"2019-10-21T02:47:56.925Z","comments":true,"path":"2019/10/21/Html/","link":"","permalink":"http://laxe.top/2019/10/21/Html/","excerpt":"HTML什么是HTML 超文本标记语言(HyperText Markup Language)，标准通用标记语言下的一个应用； 是网页制作必备的编程语言 超文本就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素 HTML不是一种编程语言，而是一种标记语言","text":"HTML什么是HTML 超文本标记语言(HyperText Markup Language)，标准通用标记语言下的一个应用； 是网页制作必备的编程语言 超文本就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素 HTML不是一种编程语言，而是一种标记语言 HTML基本结构1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题。&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 1&lt;!DOCTYPE html&gt; 声明为 1HTML 文档， 1HTML 文档也常称为网页， 一个文档包含HTML标签和文本 &lt;html&gt;与&lt;/html&gt;之间的文本描述网页，同时HTML元素也是当前页面的根元素 &lt;head&gt;是包含了文档的元(meta)数据，如定义网页编码格式&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;元素描述当前文档页面的标题 &lt;body&gt;与&lt;body&gt;之间的文本是可见的页面内容 &lt;h1&gt;与&lt;/h1&gt;之间的文本被显示为标题 &lt;p&gt;与&lt;/p&gt;之间的文本被显示为段落 HTML注释123&lt;!-- 这是一段注释 --&gt;&lt;h5&gt;这是一个H5标题。&lt;/h5&gt;&lt;!-- 记得在此处添加信息 --&gt; HTML标签 HTML标记标签通常被称为HTML标签 (HTML tag) HTML标签是由尖括号包围的关键词，比如&lt;html&gt; HTML标签通常是成对出现的，比如 &lt;b&gt;和&lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 多数情况下，HTML文档中的标签可以互相嵌套，实现更复杂的功能 基本标签 标题标签：h1~h6 123&lt;h1&gt; 这是一个最大的标题&lt;/h1&gt; 段落标签：p 123&lt;p&gt; 每一个段落标签中的内容都会换行输出&lt;/p&gt; 块级标签：div 123456789&lt;div style=\"color: #FF0000\"&gt; &lt;h1&gt; div标签常用来组合一整块标签内容 &lt;/h1&gt; &lt;p&gt; 以便通过CSS样式来对其中这些元素进行格式化控制 比如当前div标签下的所有文本均为红色 &lt;/p&gt;&lt;/div&gt; 换行标签：br 123111&lt;br&gt;222 图片标签：img 1&lt;img src='xxx.img' alt=\"图片\" /&gt; src：用来指明当前图片路径 alt：光标位于图片时所显示的内容，或是当图片加载失败时所显示的内容 链接标签：a 1&lt;a src=\"https://www.baidu.com\"&gt;百度&lt;/a&gt; href：控制访问地址 a：标签的文本元素为页面展示内容 无序列表：ul、li 12345&lt;ul&gt; &lt;li&gt;无序列表项1&lt;/li&gt; &lt;li&gt;无序列表项2&lt;/li&gt; &lt;li&gt;无序列表项3&lt;/li&gt;&lt;/ul&gt; ul:指明当前为无序列表 li:具体列表项使用这个标签 单个列表项可不加ul标签 有序列表：ol、li 12345&lt;ol&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;li&gt;C&lt;/li&gt;&lt;/ol&gt; ol：指明当前为有序列表 li：具体列表项使用这个标签 单个列表项可不加ul标签 连接外部文件 像img等类似的标签需要我们去访问一个外部文件，常用的方式有如下几种 引入外部图片： 1&lt;img src=\"img/1.jpg\" alt=\"图片\" /&gt; 引入另外一个网页： 1&lt;a src=\"other.html\"&gt;其他页面&lt;/a&gt; 引入CSS样式文件： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\" /&gt; rel：relationship的英文缩写，用于定义链接的文件和HTML文档之间的关系 stylesheet：样式表 type：外链文档的类型 href：外链文档的路径 引入js文件： 1&lt;script type=\"text/javascript\" src=\"js/jquery.js\"&gt;&lt;/script&gt; src与href： src用于引入资源，引入的资源为页面必不可少的一部分，类似换内裤 href只是引用资源，表示超文本引用，类似穿外套 相对路径：使用当前文件为起点定位资源 ./：表示位于当前文件所在目录下 ../：表示位于当前文件所处的上一层目录下 绝对路径：使用当前磁盘目录为起点定位资源 表格标签：table 表格标签由table标签进行定义 表格中的每一行由tr标签定义table row 每一行有几个单元格由td标签定义table data 表格的表头由th标签定义table header 123456789101112131415&lt;table border=\"20\"&gt; &lt;caption&gt;用户表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; border：定义表格边框，数字越大，边框越粗 caption ：定义表格标题 123456789101112131415&lt;table width=\"400\" border=\"1\" cellpadding=\"10\" cellspacing=\"3\" frame=\"box\"&gt; &lt;tr&gt; &lt;th&gt;名字&lt;/th&gt; &lt;td align=\"center\" &gt;张三&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"3\" align=\"center\"&gt;合并单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; cellpadding：规定单元格边缘和内容的空白 cellspacing：增加单元格之间的距离 12&gt; align`：设置单元格内容靠齐，可选属性有`left`、`right`以及`center&gt; frame：控制围绕表格的边框box四面环山 above：上面 below：下面 hsides：上下两侧 vsides：左右两侧 colspan：合并列 rowspan：合并行 表单标签：form 表单用于收集不同类型的用户输入，表单由不同类型的标签组成 单行文本输入框 12&lt;label&gt;姓名：&lt;/label&gt;&lt;input type=\"text\" name=\"username\" value=\"张三\" /&gt;&lt;label&gt;密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; text：单行文本框 password：密码输入框 value：定义表单元素的值 name：定义表单元素的名称，提交到后台时通过该值获取对应表单中的数据 单选框 12&lt;input type=\"radio\" name=\"gender\" value=\"0\" /&gt; 男&lt;input type=\"radio\" name=\"gender\" value=\"1\" /&gt; 女 在单选框中的name属性可以控制哪几个表单为一组 复选框 123&lt;input type=\"checkbox\" name=\"like\" value=\"sing\" /&gt; 唱歌&lt;input type=\"checkbox\" name=\"like\" value=\"run\" /&gt; 跑步&lt;input type=\"checkbox\" name=\"like\" value=\"swiming\" /&gt; 游泳 上传文件 1&lt;input type=\"file\" name=\"picture\"&gt; 多行文本输入框 1&lt;textarea name=\"about\"&gt;&lt;/textarea&gt; 下拉表单元素：select 123456&lt;select name=\"site\"&gt; &lt;option value=\"0\"&gt;北京&lt;/option&gt; &lt;option value=\"1\"&gt;上海&lt;/option&gt; &lt;option value=\"2\"&gt;广州&lt;/option&gt; &lt;option value=\"3\"&gt;深圳&lt;/option&gt;&lt;/select&gt; option：下拉框中的具体属性 value：在表单提交时真正发送给服务器的值 提交按钮：submit 点击时触发form标签中的action动作 重置按钮：reset 重置所属表单中所有表单框的所填数据 普通按钮：button 123&lt;input type=\"submit\" value=\"提交\"&gt;&lt;input type=\"reset\" value=\"重置\"&gt;&lt;input type=\"button\" value=\"按钮\"&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django-Views-视图层","slug":"Django-Views-视图层","date":"2019-10-21T02:17:20.957Z","updated":"2019-10-21T02:18:09.682Z","comments":true,"path":"2019/10/21/Django-Views-视图层/","link":"","permalink":"http://laxe.top/2019/10/21/Django-Views-视图层/","excerpt":"视图层 视图函数一般用来接收一个Web请求HttpRequest，之后返回一个Web响应HttpResponse HttpRequest 一个视图函数用来响应用户的Request请求，每个视图函数默认的第一个位置参数request用来接收用户发起请求的HttpRequest信息。 视图函数的返回值，为一个HttpResponse值，包括我们要返回给用户的HTML页面或者字符串等等，以及对应的头部字段信息","text":"视图层 视图函数一般用来接收一个Web请求HttpRequest，之后返回一个Web响应HttpResponse HttpRequest 一个视图函数用来响应用户的Request请求，每个视图函数默认的第一个位置参数request用来接收用户发起请求的HttpRequest信息。 视图函数的返回值，为一个HttpResponse值，包括我们要返回给用户的HTML页面或者字符串等等，以及对应的头部字段信息 123from django.http import HttpResponsedef index(request): return HttpResponse('Hello world') 常见请求方式 POST和GET是HTTP协议定义的与服务器交互的方法。 GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。另外，还有PUT和DELETE方法 get 常用来从指定地址请求数据； 如果需要在请求时提交某些数据，则以路由形式传递参数，查询Query字符串如下格式所示： 1https://www.baidu.com/?key=abc&amp;pos=shanxi get请求可被浏览器缓存，保存在历史记录中 get不应在使用敏感数据时使用，明文包路在请求地址中 get有长度限制 post 向指定的资源提交要被处理的数据 使用POST，提交的数据保存在HTTP协议中的消息主体部分 post请求不会被浏览器缓存 post提交数据长度无限制 post比get更加安全 request 如果说urls.py是Django中前端页面和后台程序桥梁，那么request就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于requests中 request.method 获取当前用户请求方式， 请求方式字符串为纯大写：&#39;GET&#39;、&#39;POST&#39; 如用户以get方式发起请求，对应代码中获取到的结果以及在判断时像是这样 123def index(request): if request.method == 'GET': … request.GET 当用户通过get方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值 123456789def index(request): print(request.GET) # &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt; print(type(request.GET)) # &lt;class 'django.http.request.QueryDict'&gt; name_ = request.GET.get('name') id_ = request.GET.get('id') content = '%s:%s' % (name_,id_) return HttpResponse(content) 12&gt; request.GET`是一个类似字典的数据类型：`QueryDict&gt; 其中也支持类似对字典的get或直接dict.[key]键值访问方式，当然使用get方式进行对应key获取会更好，因为get在访问不到时不会报错 如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参： 1http://127.0.0.1:8000/?name=jack&amp;id=1 这里对应页面会显示的结果： 1jack:1 注意：使用GET方法在连接中进行参数提交，后台接收到的数据类型均是字符串 request.POST 获取用户以post形式提交的数据并保存在后台，为类字典数据，这里和request.GET是一个东西； 在网页中，一般我们通过html的表单进行数据的提交，POST方式可以提交空数据 因为涉及到了表单页面，所以我们先来弄一个HTML页面 12345678910&lt;body&gt; &lt;div&gt;这是一个关于POST的测试&lt;/div&gt; &lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; 账号:&lt;input type=\"text\" name=\"account\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"passwd\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; 在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加csrf_token标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。 在接下来的视图函数中会使用到input标签中的name属性； name值属性维护了post的数据传入到后台时的标示，会与表单的数据组合成类字典格式 如name属性为account的输入框中输入了test，那么后台数据接收到的值类似：{&#39;account&#39;:&#39;test&#39;} 写一个视图函数用来捕获当前表单使用POST形式提交的数据： 123456789def index(request): if request.method=\"POST\": print(request.POST) print(type(request.POST)) account = request.POST.get(\"account\") passwd = request.POST.get(\"passwd\") content = \"%s:%s\" % (account,passwd) return HttpResponse(content) return render(request,\"index.html\") #在使用get形式请求时，返回表单页面 如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为： 1&lt;QueryDict: &#123;'csrfmiddlewaretoken': ['EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2'], 'account': ['test'], 'passwd': ['123456']&#125;&gt; 表单多值提交 在request.POST中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框CheckBox，直接使用request.POST.get()进行获取是有一些问题的，比如修改模板页面如下所示 1234567&lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"checkbox\" name=\"taste\" value=\"eat\"&gt;吃 &lt;input type=\"checkbox\" name=\"taste\" value=\"sleep\"&gt;睡 &lt;input type=\"checkbox\" name=\"taste\" value=\"play\"&gt;耍 &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 这是一个name值为taste的兴趣爱好采集的多选框，value值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的 1&lt;QueryDict: &#123;'csrfmiddlewaretoken': ['nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k'], 'taste': ['eat', 'sleep', 'play']&#125;&gt; 但是问题接踵而至，我们发现使用get函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项 request.POST.get(key, default=None) 返回对应key值的数据中的最后一个数据单独返回；key值不存在，取default 要想真正拿出所有的结果，应该使用getlist函数 request.POST.getlist(key, default=None) 将对应key值的所有数据以一个列表形式返回；key值不存在，取default request.META request.MATE获取的是一个标准的python字典。它包含了所有的HTTP请求信息 比如用户IP地址和用户Agent（通常是浏览器的名称和版本号）。 注意，Header信息的完整列表取决于用户所发送的Header信息和服务器端设置的Header信息 CONTENT_LENGTH：请求的正文的长度，字符串类型 CONTENT_TYPE：请求的正文的MIME 类型 HTTP_ACCEPT：响应可接收的Content-Type HTTP_ACCEPT_ENCODING：响应可接收的编码 HTTP_ACCEPT_LANGUAGE：响应可接收的语言 HTTP_HOST：客服端发送的HTTP Host头部 HTTP_REFERER：请求前的连接地址 HTTP_USER_AGENT：客户端的user-agent字符串 QUERY_STRING：单个字符串形式的查询字符串（未解析过的形式） REMOTE_ADDR：客户端的IP 地址 REMOTE_HOST：客户端的主机名 REMOTE_USER：服务器认证后的用户 REQUEST_METHOD：一个字符串，例如GET 或POST SERVER_NAME：服务器的主机名 SE0RVER_PORT：服务器的端口，字符串类型 request.FILES 接收用户上传文件及相关信息。同样类似于request.POST，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息 f = request.FILES.get(&#39;upload_file&#39;) file_data = f.read()：读取整个上传文件的内容，适合小文件上传 yiled = f.chunks()：返回一个类似生成器（&lt;class &#39;generator&#39;&gt;）的数据，每一次读取按块返回文件，可以通过for迭代访问其中数据；适合上传大文件到服务器。 f.multiple_chunks()：返回文件大小，当文件大小大于2.5M时，返回True，反之返回False，可以通过该函数来选择是否使用chunks方法或read直接存储。 如果想要修改这个文件判定的默认值，可以通过：FILE_UPLOAD_MAX_MEMORY_SIZE在settings文件下进行设置 f.content_type：上传文件时头部中的Content-Type字段值，参考MIME类型 f.name：上传文件名字 f.charset：上传文件编码 f.size： 上传文件大小，字节为单位：byte 创建好静态资源目录，并在下面创建一个img文件夹，保存我们即将上传的图片； 完成上传文件的HTML表单页面 1234567&lt;form action=\"/\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"file\" name=\"upload_file\" /&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; &lt;img src=\"&#123;% static 'img/1.jpg' %&#125;\" alt=\"这是一张图片\"&gt;&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt; 注意：上传文件的页面表单，一定要记得设置属性enctype=&quot;multipart/form-data&quot; 视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中 12345678910111213def index(request): if request.method == \"POST\": f = request.FILES.get(\"upload_files\") path = os.path.join(settings.STATICFILES_DIRS[0],'img/'+f.name) # 上传文件本地保存路径 with open(path,'wb') as fp: if f.multiple_chunks: #判断到上传文件为大于2.5MB的大文件 for buf in f.chunks(): #迭代写入文件 fp.write(buf) else: fp.write(f.read()) return HttpResponse(\"Success!\") return render(request, 'index.html') 测试上传一个名为1.jpg的图片，如果成功上传，那么后台static目录下会出现该图片，并且模板页面也可以展示对应图片效果 HTTPResponse 一个视图的返回值经常是为了向用户返回一个HttpResponse响应， 有如下常用的可以返回HttpResponse的函数 response HttpResponse(content=b&#39;&#39;) 返回一个字符串内容 from django.http import HttpResponse render(request,template_name,context=None,content_type=None,status=None) 返回一个可渲染HTML页面，状态码为200 from django.shortcuts import render request：固定参数，响应的request请求，来自于参数部分接收的HttpRequest template_name：返回的模板页面路径 context：模板页面渲染所需的数据，默认为字典格式 content_type：生成之后的结果使用的MIME类型 status：响应的状态码，默认为200 redirect(to, permanent=False) 一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码302 from django.shortcuts import redirect to：可以是一个django项目中视图函数的路由映射，也可以是一个reverse的反向路由解析 permanent：如果设置为True，将返回301状态码，代表永久重定向 12302：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。301：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址 视图错误处理 为了方便我们开发，django提供了一个异常叫做Http404异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后django项目会自动捕获该异常，并会展示默认的404页面 1234from django.http import Http404def index(request): if request.GET.get(\"id\") == \"1\": raise Http404 在settings中的debug配置项为false时，访问http://127.0.0.1:8000/?id=1，可以看到django为我们提供的错误页面； 除了django默认提供的，我们还可以可以在模板目录下定义全局404.html进行错误页面的定制 123&lt;h1&gt; 抱歉，找不到你要的东西&lt;/h1&gt; 自定义错误处理视图 除去404错误的自定义，django还提供了覆盖默认错误行为处理的办法； 有些时候，django自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数， 来覆盖掉django所提供的错误处理视图函数，最后在urls.py路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数 1234567891011121314handler404：覆盖page_not_found()视图。handler500：覆盖server_error()视图。handler403：覆盖permission_denied()视图。 handler400：覆盖bad_request()视图from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('', include(\"viewapp.urls\")),]handler404 = \"viewapp.views.error_404\"# APP.模块.视图函数handler500 = \"viewapp.views.error_500\" 相关定义好的错误处理视图函数 12345678def error_404(request): return HttpResponse(\"这是404错误\")def error_403(request): return HttpResponse(\"这是403错误\")def error_500(request): return HttpResponse(\"这是500错误\")","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django-Models-模型层","slug":"Django-Models-模型层","date":"2019-10-21T02:12:43.264Z","updated":"2019-10-21T02:13:34.002Z","comments":true,"path":"2019/10/21/Django-Models-模型层/","link":"","permalink":"http://laxe.top/2019/10/21/Django-Models-模型层/","excerpt":"模型层 该层开发的首要任务就是定义模型类以及属性 每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段 配置Mysql数据库 在确保mysql数据库可以连接使用的情况下； 首先在数据库中创建专为django使用的库django_data","text":"模型层 该层开发的首要任务就是定义模型类以及属性 每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段 配置Mysql数据库 在确保mysql数据库可以连接使用的情况下； 首先在数据库中创建专为django使用的库django_data 1create database django_data; 配置django的settings.py文件中的DATABASES属性如下 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': \"django_data\", # 使用的库名 \"USER\": \"root\", # 用户名 \"PASSWORD\": \"123456\", # 数据库密码 \"HOST\": \"localhost\", # 数据库主机地址 \"PORT\": \"3306\" &#125;&#125; 由于使用django的Python版本为3+； 此时对于mysql的支持已经变为pymysql，而对于django加载数据库引擎时还需要使用2版本的mysqldb名称 现在先需要我们安装pymysql之后在项目中重申mysql引擎 首先安装pymysql 1pip install pymysql -i https://pypi.tuna.tsinghua.edu.cn/simple 项目主目录下的__init__文件中添加如下内容 12import pymysqlpymysql.install_as_MySQLdb() 现在整个项目的数据库使用已经切换到了mysql 模型层字段 在模型层类中的字段即是数据库中表的字段，表的字段设计非常重要 每一个字段都是Field基类的一个实例（Field类用来建立字段与数据库之间的映射） 模型字段定义不能以下划线结尾 django会根据在模型类中定义的字段属性来确定以下几点工作 数据库中使用的数据类型 模型类对应的表单类渲染时使用的表单类型及HTML部件 必填字段等最低限度的验证要求检查，包括admin界面下自动生成的表单 BooleanField BooleanField(**options)：True/False字段，默认值为None 表单类型：CheckboxInput，&lt;input type=&#39;checkbox&#39; ...&gt; CharField CharField(max_length=None)：字符串字段 含有一个必须参数：max_length设置最大的字符数长度限制； 表单类型：TextInput，&lt;input type=&quot;text&quot; ...&gt; DateField DateField(auto_now=False, auto_now_add=False,**options)：以 datetime.date实例表示的日期 含有两个可选参数：auto_now、auto_now_add auto_now：该值为True时，每次在保存数据对象时，自动设置该字段为当前时间，也可以理解为自动更新最后一次修改时间 auto_now_add：该值为True时，该字段设置在第一次数据对象创建时，可以记录当前字段创建的时间值 注意：避免矛盾，auto_now，auto_now_add，default不能同时出现，一个字段属性只能有其中一条设置，当设置了auto_now，或auto_now_add时，也会让该字段默认具有blank=True（字段可以为空）属性 表单类型：TextInput，&lt;input type=&quot;text&quot; ...&gt; DatetimeField DatetimeField(auto_now=False, auto_now_add=False,**options)：以datetime.datetime实例表示的日期和时间 和DateField具有相同的字段属性 DecimalField DecimalField(max_digits=None,decimal_places=None, **options)：以Decimal实例标示的十进制浮点数类型 含有两个可选参数：max_digits、decimal_places max_digits：位数总数，包括小数点后的位数，必须大于decimal_places参数 decimal_places：小数点后的数字数量，精度 表单类型：TextInput，&lt;input type=&quot;text&quot; ...&gt; EmailField EmailField(max_length=254, **option)：CharField子类，表示Email字段，并会检查是否为合法邮箱地址 默认参数：max_length，表示邮箱地址长度，默认为254 表单类型：TextInput，&lt;input type=&quot;text&quot; ...&gt; FloatField FloatField(**options)：使用float实例来表示的浮点数 表单类型：TextInput，&lt;input type=&quot;text&quot; ...&gt; IntegerField 12&gt; IntegerField(**options)`：一个整数，范围由`-2147483648`到`2147483647&gt; GenericIPAddressField GenericIPAddressField(protocol=both, unpack_ipv4=False, **options)：一个IPV4或IPV6地址的字符串 默认参数：protocol、unpack_ipv4 protocol：IP协议，ipv4或ipv6，默认both为全选 unpack_ipv4：解析IP地址，只有当协议为both时才可以使用 表单类型：TextInput，&lt;input type=&quot;text&quot;...&gt; SlugField SlugField(max_length=50, **option)：只包含字母、数字、下划线的字符串，常用来表示连接中的path部分或者一些其他短标题类型数据 TextField TextField(**options)：大文本字段 表单类型：Textarea，&lt;textarea&gt;...&lt;/textarea&gt; URLField URLField(max_length=200, **options)：CharField的子类，存储URL的字段 表单类型：TextInput，&lt;input type=&quot;text&quot;...&gt; 字段属性 以上所介绍的字段，均支持以下属性 null 如果该值为True，Django将在数据库中将控制存储为NULL 字符串字段CharField与TextField要避免使用null，因为空值字符串将存储空字符串（””）,而不是null值。 对于字符串类型的数据字段，大多数情况下，django使用空字符串代表空值 blank 如果该值为True，则在验证时该字段值可以为空； null为数据库存储层面可以为空，而blank为表单验证层面可以填写空值 choices 一个二元组的列表或元组； 元组中第一个值为真正在数据库中存储的值，第二个值为该选项的描述 该值一旦被设定，表单样式会显示选择框，而不是标准的文本框，选择框内的选项为choices中的元组 1234567class TestTable(models.Model): CHAR_CHOICE = [ ('H',\"非常苦难\"), ('M',\"中等难度\"), ('S',\"非常简单\"), ] choicechar = modesl.CharField(max_length=1,choices=CHAR_CHOICE) choices字段也支持分类的写法 12345678910111213CHAR_CHOICE = [ ('A', ( ('H',\"Hard\"), ) ), ('B', ( ('M',\"Medium\"), ) ), …] 分类的名称作为元组中的第一个值， 元组的第二个值为该分类下的一个新的二元组序列数据 db_column 数据库中用来表示该字段的名称，如果未指定，那么Django将会使用Field名作为字段名 db_index 当该值为True时，为该字段创建索引 default 该字段默认值，可以是一个值或是一个回调函数 当是一个函数对象时，在创建新对象时，函数调用 editable 如果设置该值为False，那么这个字段将不允许被编辑 不会出现在admin后台界面下，以及其他ModelForm表单中，同时也会跳过模型验证 primary_key 设置该值为True时，该字段成为模型的主键字段，一个模型类同时只能有一个主键 如果一个表中不存在任意一个设置好的主键字段，django会自动设置一个自增的AutoField字段来充当主键，该值可以用pk，id方式获取。主键的设置还意味着，null=False，unique=True unique 如果该值为True，代表这个数据在当前的表中有唯一值 这个字段还会在模型层验证存储的数据是否唯一 unique的设置也意味着当前字段具备索引的创建 ManyToManyField、OneToOneField与FileField字段不可以使用该属性 verbose_name 对于字段的一个可读性更高的名称 如果没有设置该值，django将字段名中的下换线转换成空格，作为当前字段的数据库中名称 模型元属性 在模型类的Meta类中，可以提供一系列的元选项，可以方便对该模型类进行属性设置或约束等 12345class TestTable(models.Model): … class Meta: ordering = [Fields] … abstract 代表当前模型类为抽象基类，不会创建真正的数据表，只是为了其他模型类继承使用 1abstract = True app_label 当模型类被定义在了其他app下，这个属性用来描述当前表属于哪个app应用 1app_label = \"MyApp\" db_table 当前模型类所对应的表名，未设置时，django默认将表名与app名由下划线组成，作为表名 需要注意这个表名为真实在数据库中所使用的，所以该元选项的使用应在数据表创建之前 如果在表已经存在的情况下去修改，会导致数据库内表与模型类表名不一致而查找不到报错 ordering 当前表中的数据存储时的排序规则，这是一个字段名的字符串，可以是一个列表或元组； 每一个字符串前可以使用”-“来倒序排序，使用”?“随机排序 ordering排序规则的添加，也会增加数据库的开销 12ordering = ['-birthday', 'age']#先按照birthday倒序排序，再按照age字段进行排序。 unique_together 用来设置表中的不重复字段组合 格式为一个元组，元组中的每个数据都是一个元组，用来描述不重复的组合字段 如果只处理单一字段组合，可以是一个一维的元组 联合约束 1unique_together = (('name','phone'),) verbose_name 一般设置该表展示时所用的名称，名称被自动处理为复数，字符串后加一个”s” verbose_name_plural 与verbose_name功能相同，但是不会自动在字符串后加”s“以表复数 设置表的复数名称 模型操作 在进行模型操作的学习之前，可以先创建一个测试的数据库模型类，如下所示 123class Person(models.Model): name = models.CharField(max_length=10,verbose_name=\"姓名\") age = models.IntegerField(verbose_name=\"年龄\") 创建对象 django自带了一个数据库测试的shell工具 这是一个非常方便可以让我们对django代码进行测试的环境 可以直接通过python manage.py shell命令行管理工具来打开 实例save创建数据 通过模型类的关键词参数实例化一个对象来进行数据的创建 123&gt;&gt;&gt; from app.models import Person&gt;&gt;&gt; p1 = Person(name='张三',age=15)&gt;&gt;&gt; p1.save() 以上的代码，在为字段赋予值之后，通过实例的save函数进行该数据的保存 在数据库底层执行了SQL语句中的insert操作，并且，在我们显示调用save之前，django不会访问数据库，实例数据只存在于内存中 注意：save函数没有返回值 create方法创建数据1&gt;&gt;&gt; P1 = Person.objects.create(name='李四',age=20) 这条语句创建一条数据，并且返回一个数据在内存中的实例P1 之后可以通过这个实例字段P1对数据库中该条数据进行修改或删除操作 create 方法一步到位，save方式可以慢悠悠的赋予字段值，最后赋予结束再save 查找对象 接下来，我们将通过模型类中的管理器进行数据的查询； 管理器（Manager）是每一个模型类所具有的，默认名为objects 模型类通过模型类调用orm数据接口，其实就是在对数据表进行操作。 注意，具体的某一条数据无法访问这个管理器 all() 获取一个表中的所有数据，返回QuerySet数据对象 1all_person = Person.objects.all() filter(**kwargs) 返回一个包含数据对象的集合，满足参数中所给的条件 12res = Person.objects.all().filter(age__lt=16)res = Person.objects.filter(age__lt=16) 我们在查询过程中，除了直接使用字段属性进行验证 还可以在字段名之后使用双下化线来标明更加详细的字段筛选条件（在下一节会有详细的字段筛选条件介绍），也叫做链式过滤 这也是为什么表单类字段不可以以下换线结尾的原因 exclude(**kwargs) 返回一个包含数据对象的集合，数据为不满足参数中所给的条件 filter()查询会始终返回一个结果集，哪怕只有一个数据。 但是有些时候，我们对于一些在数据表中的唯一数据进行查询时，可以使用更加合适的get方法 注意：创建结果集的过程不涉及任何数据库的操作，查询工作是惰性的，在上面的查询方式中，查询代码不会实际访问数据库，只有查询集在真正使用时，django才会访问数据库 get(**kwargs) 获取唯一单条数据 get获取数据只会返回一条匹配的结果，获取的数据只能在数据库中有一条 如果返回多个结果，会引发MultipleObjectsReturned异常 如果没有任何匹配到的结果也会引发DoesNotExist异常 1Person.objects.get(pk=1) order_by(*field) 默认情况下，数据表使用模型类中的Meta中指定的ordering选项进行排序 现在也可以通过使用order_by函数进行查询结果的排序 1Person.objects.order_by('age') 1Person.objects.all().order_by('-age') count() 返回数据库中对应字段的个数，并且该函数永远不会引发异常 12models.Person.objects.filter(age=20).count()Person.objects.count() 使用count函数时，还需要对数据表进行迭代访问 所以有时使用已生产好的结果集，通过len函数获取长度，这种方式效率会更高 count方法的调用会导致额外的数据库查询 values(*fields) 返回一个查询集结果，但是迭代访问时返回的是字典，而不是数据实例对象 12models.Person.objects.all().values()models.Person.objects.values() 链式过滤条件 exact 如果在查询过程中，没有提供查询类型（没有双下划线），那么查询类型就会被默认指定为exact，这是一种严格查找的方式，用来在数据库中查找和查询时的关键词参数完全一致的内容 12&gt;&gt;&gt; Person.objects.filter(account='root')&gt;&gt;&gt; Person.objects.filter(account__exact='root') iexact 忽略大小写的匹配 12&gt;&gt;&gt; Person.objects.filter(account__iexact='root')#匹配到的结果可能是Root，ROot，ROOt，ROOT startswith、endswith 分别匹配开头和结尾，区分大小写 12&gt;&gt;&gt; Person.objects.filter(passwd__startswith='admin')#匹配以admin开头的数据 istartswith、iendswith 分别匹配开头和结尾，忽略大小写 12&gt;&gt;&gt; Person.objects.filter(passwd__istartswith='admin')匹配以不区分大小写的字符串admin为开头的数据 gte 大于或等于 1&gt;&gt;&gt; Person.objects.filter(reg_data__gte=datetime.date.today) lte 小于或等于 1&gt;&gt;&gt; Person.objects.filter(reg_data__lte=datetime.date.today) 修改对象 获取到对应的数据实例之后，通过.的方式访问数据实例中的属性，进行数据的字段修改 123p = models.Person.objects.get(pk=1)p.age = 21p.save() 对过滤出的结果链式调用update()函数，这样的修改，类似批量修改，update函数会返回成功修改的个数 12models.Person.objects.filter(age__gt=100).update(age=25)# 将所有年纪小于100的人的年纪改为20 删除对象 对于普通的单表数据删除，获取到数据实例对象后调用内置的delete()函数即可 1models.Person.objects.get(pk=1).delete() 需要注意的是，删除一条数据之后，默认占有的主键ID值并不会被下一个新插入的值所占用 比如 1，2，3，4；删除掉3之后，剩下：1，2，4；下一个值存储时，id是5，3不会被复用 字段关系 字段关系是django维护表关系的方式；其中主要有一对一，多对一以及多对多， 现在的一对一及多对一关系中需要设置on_delete属性用来描述当关联数据被删除时的操作，有如下一些 models.CASCADE：删除关联数据,与之关联也删除 models.PROTECT：删除关联数据,引发错误ProtectedError models.SET_NULL：与之关联的值设置为null（前提FK字段需要设置为可空） models.SET_DEFAULT： 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值） models.DO_NOTHING：删除关联数据,什么也不做 一对一关系 模型类使用OneToOneField用来定义一对一关系； 比如当你拥有一个老师表时，紧接着你还需要一个教授表，那么教授表可能拥有老师表的一系列属性，那么你还不想把老师表中的字段直接复制到教授表那么可以通过OnToOneField来实现教授表继承老师表。 其实，在使用模型类继承时，也隐含有一个一对一关系 OneToOneField(to, on_delete, parent_link=False, options) 12345678910class Teacher(models.Model): name = models.CharField(max_length=50) age = models.CharField(max_length=50) def __str__(self): return self.nameclass Professor(models.Model): teacher = models.OneToOneField(Teacher,primary_key=True,on_delete=models.CASCADE) big_project = models.CharField(max_length=50) def __str__(self): return self.teacher.name 在manage.py shell下进行数据库操作 123456789&gt;&gt;&gt; t1 = Teacher.objects.create(name='Jack',age='22')&gt;&gt;&gt; t2 = Teacher.objects.create(name='Bob',age='17')&gt;&gt;&gt; p1 = Professor.objects.create(teacher=t1,big_project='雾霾净化术')&gt;&gt;&gt; p1.teacher&lt;Teacher: Jack&gt;&gt;&gt;&gt; p1.teacher = t2&gt;&gt;&gt; p1.save()&gt;&gt;&gt; p1.teacher&lt;Teacher: Bob&gt; 在上面的测试中，看似已经将p1对应的教授变成了Bob； 但是在数据库中之前t1老师所对应的教授信息还存在，此时的赋值操作并不会覆盖掉教授他之前的教授数据，只是重新创建了一条。 正确的做法应该是将某一条数据的一对一关系通过delete关系先删除之后再重新赋予 多对一关系 Django使用django.db.models.ForeignKey定义多对一关系。 ForeignKey需要一个位置参数：与该模型关联的类 生活中的多对一关系：班主任，班级关系。一个班主任可以带很多班级，但是每个班级只能有一个班主任 1234567891011121314151617class Headmaster(models.Model): name = models.CharField(max_length=50) def __str__(self): return self.nameclass Class(models.Model): class_name = models.CharField(max_length=50) teacher = models.ForeignKey(Headmaster,null=True,on_delete=models.SET_NULL) def __str__(self): return self.class_name&gt;&gt;&gt; H1 = Headmaster(name='渔夫')&gt;&gt;&gt; H1.save()&gt;&gt;&gt; H1&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; H2 = Headmaster(name='农夫')&gt;&gt;&gt; H2.save()&gt;&gt;&gt; Headmaster.objects.all()[&lt;Headmaster: 渔夫&gt;, &lt;Headmaster: 农夫&gt;] 以上创建了两条老师数据 由于我们设置外键关联可以为空null=True,所以此时在班级表创建时，可以直接保存，不需要提供老师数据 12345678&gt;&gt;&gt; C1 = Class(class_name='一班')&gt;&gt;&gt; C2 = Class(class_name='二班')#如果外键设置不为空时，保存会引发以下错误# IntegrityError: NOT NULL constraint failed: bbs_class.teacher_id&gt;&gt;&gt; C1.teacher = H1&gt;&gt;&gt; C2.teacher = H2&gt;&gt;&gt; C1.save()&gt;&gt;&gt; C2.save() 将老师分配个班级之后，由于班级表关联了老师字段，我们可以通过班级找到对应老师 虽然老师表中没有关联班级字段，但是也可以通过老师找到他所带的班级，这种查询方式也叫作关联查询 通过模型类名称后追加一个’_set’，来实现反向查询 12&gt;&gt;&gt; H1.class_set.all()&lt;QuerySet [&lt;Class: 一班&gt;]&gt; 由于我们这是一个多对一的关系，也就说明我们的老师可以对应多个班级 我们可以继续给H1老师分配新的班级 12345&gt;&gt;&gt; C3 = Class(class_name='三班')&gt;&gt;&gt; C3.teacher = H1&gt;&gt;&gt; C3.save()&gt;&gt;&gt; H1.class_set.all()[&lt;Class: 一班&gt;, &lt;Class: 三班&gt;] 一个班级只能对应一个老师，外键是唯一的，那么你在继续给C1班级分配一个新的老师时，会覆盖之前的老师信息，并不会保存一个新的老师 12345678&gt;&gt;&gt; H3 = Headmaster(name='伙夫')&gt;&gt;&gt; H3.save()&gt;&gt;&gt; C1.teacher&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; C1.teacher=H3&gt;&gt;&gt; C1.save()&gt;&gt;&gt; C1.teacher&lt;Headmaster: 伙夫&gt; 把这个班级的老师删除，由于设置了外键字段可以为null，此时班级的老师选项为null 123456789101112131415&gt;&gt;&gt; t1 = Headmaster.objects.all().first()&gt;&gt;&gt; t1&gt;&gt;&gt; c1 = Class.objects.all().first()&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; c1&lt;Class: 一班&gt;&gt;&gt;&gt; c1.teacher&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; t1.delete()(1, &#123;'modelsapp.Headmaster': 1&#125;)&gt;&gt;&gt; c1 = Class.objects.all().first()&gt;&gt;&gt; c1&lt;Class: 一班&gt;&gt;&gt;&gt; c1.teacher&gt;&gt;&gt; #这里什么都没有，因为此时C1的老师已经是个None了 要记得删除之后要重新获取一次数据，否则查看到的结果中还是之前获取到的有老师的班级数据 多对多关系 多对多关系在模型中使用ManyToManyField字段定义 多对多关系可以是具有关联，也可以是没有关联，所以不需要明确指定on_delete属性 生活中，多对多关系：一个音乐家可以隶属于多个乐队，一个乐队可以有多个音乐家 123456789class Artist(models.Model): artist_name = models.CharField(max_length=50) def __str__(self): return self.artist_nameclass Band(models.Model): band_name = models.CharField(max_length=50) artist = models.ManyToManyField(Artist) def __str__(self): return self.band_name 创建音乐家以及乐队 12345&gt;&gt;&gt; from bbs.models import Artist,Band&gt;&gt;&gt; A1 = Artist.objects.create(artist_name='Jack')&gt;&gt;&gt; A2 = Artist.objects.create(artist_name='Bob')&gt;&gt;&gt; B1 = Band.objects.create(band_name='FiveMonthDay')&gt;&gt;&gt; B2 = Band.objects.create(band_name='SHE') 创建出两个乐队之后对其进行音乐家的添加 多对多字段添加时，可以使用add函数进行多值增加 12&gt;&gt;&gt; B1.artist.add(A1,A2)&gt;&gt;&gt; B2.artist.add(A2) B1乐队含有A1,A2两名成员 B2乐队含有A1成员 1234&gt;&gt;&gt; B1.artist.all()[&lt;Artist: Bob&gt;, &lt;Artist: Jack&gt;]&gt;&gt;&gt; B2.artist.all() [&lt;Artist: Jack&gt;] 可以在音乐家表中查找某个乐家属于哪些乐队 1234&gt;&gt;&gt; Band.objects.filter(artist=A1) # 这里使用的是我们模型类来进行查找。[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;] # A1乐家属于，SHE以及FiveMonthDay&gt;&gt;&gt; Band.objects.filter(artist=A2)[&lt;Band: SHE&gt;] 也可以查找这音乐家在哪个乐队 1234&gt;&gt;&gt; A1.band_set.all() # 直接通过具体数据对象进行查找[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;]&gt;&gt;&gt; A2.band_set.all()[&lt;Band: SHE&gt;] 多对多关联字段的删除，要使用remove来进行关系的断开 而不是直接使用delete，remove只会断开数据之间的联系，但是不会将数据删除 现在在B1乐队中删除A1乐家 123&gt;&gt;&gt; B1.artist.remove(A1)&gt;&gt;&gt; B1.artist.all()&lt;QuerySet [&lt;Artist: Bob&gt;]&gt; 关联表的查询 如果想要查询的字段在关联表，则使用表名小写__字段来进行跨表查询操作 创建一个多对一关系的父子表，一个父亲可能有多个儿子 12345678910class Father(models.Model): name = models.CharField(max_length=30) age = models.CharField(max_length=30) def __str__(self): return self.nameclass Son(models.Model): father = models.ForeignKey(Father,on_delete=models.CASCADE) name = models.CharField(max_length=30) def __str__(self): return self.name 创建数据 123456&gt;&gt;&gt; f1 = Father.objects.create(name='Jack',age='30')&gt;&gt;&gt; s1 = Son.objects.create(name='Json',father=f1)&gt;&gt;&gt; s2 = Son.objects.create(name='Json2',father=f1)&gt;&gt;&gt; f2 = Father.objects.create(name='Bob',age='40')&gt;&gt;&gt; s3 = Son.objects.create(name='Json3',father=f2) 查询所有父亲名字是jack的孩子 12&gt;&gt;&gt; Son.objects.filter(father__name__exact='Jack')[&lt;Son: Json&gt;, &lt;Son: Json2&gt;] 查询所有儿子名开头为J的父亲 12&gt;&gt;&gt; Father.objects.filter(son__name__startswith='J')[&lt;Father: Jack&gt;, &lt;Father: Jack&gt;, &lt;Father: Bob&gt;] 获取到某一个父亲的所有孩子，通过某一条数据的小写表名_set反向查询 12&gt;&gt;&gt; f1.son_set.all()&gt;&gt;&gt; [&lt;Son: Json&gt;, &lt;Son: Json2&gt;] 数据的反向查询 默认的，当有某一条数据获取到之后，我们可以通过模型类名称加上一个 _set，来实现反向查询 现在设计两个表为军队和士兵表，并且士兵多对一关联军队 123456789class Aramy(models.Model): name = models.CharField(max_length=30) def __str__(self): return self.nameclass Soldier(models.Model): aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE) name = models.CharField(max_length=30) def __str__(self): return self.name 创建一些数据 123456&gt;&gt;&gt; a1 = Aramy(name='一军')&gt;&gt;&gt; a1.save()&gt;&gt;&gt; s1 = Soldier(name='张三',aramy=a1)&gt;&gt;&gt; s1.save()&gt;&gt;&gt; s2 = Soldier(name='李四',aramy=a1)&gt;&gt;&gt; s2.save() 通过soldier_set我们就可以关联到对应的士兵表 并且对应返回结果可以执行我们常用的filter，exclude等查询操作 1234&gt;&gt;&gt; a1.soldier_set.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]&gt;&gt;&gt; a1.soldier_set.filter(name='张三')[&lt;Soldier: 张三&gt;] 也可以通过定义关联字段中的related_name值，来实现自定义的反向查询名字 且related_name的值必须唯一 123456789class Aramy(models.Model): name = models.CharField(max_length=30) def __str__(self): return self.nameclass Soldier(models.Model): aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE,related_name='soldier') name = models.CharField(max_length=30) def __str__(self): return self.name 接下来通过某条数据反向查询 1234&gt;&gt;&gt; a1 = Aramy.objects.all()[0]&gt;&gt;&gt; s1 = Soldier.objects.get(name='张三')&gt;&gt;&gt; a1.soldier.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;] 注意：related_name一定是一个唯一的值，否则反向查找时会出现二异性错误 也可以将related_name初始化为+，来取消反向查询","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2019-10-21T02:11:28.147Z","updated":"2019-10-21T02:12:24.966Z","comments":true,"path":"2019/10/21/Cookie和Session/","link":"","permalink":"http://laxe.top/2019/10/21/Cookie和Session/","excerpt":"Cookie和Session Cookie及Session一直以来都是Web开发中非常关键的一环，因为HTTP协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入Cookie或者Seesion来解决这个问题。","text":"Cookie和Session Cookie及Session一直以来都是Web开发中非常关键的一环，因为HTTP协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入Cookie或者Seesion来解决这个问题。 当客户端访问时，服务端会为客户端生成一个Cookie键值对数据，通过Response响应给到客户端。当下一次客户端继续访问相同的服务端时，浏览器客户端就会将这个Cookie值连带发送到服务端。 Cookie值存储在浏览器下，一般在你的浏览器安装目录的Cookie目录下，我们也可以通过F12或者各种浏览器的开发者工具来获取到 因为cookie是保存在浏览器中的一个纯明文字符串，所以一般来说服务端在生成cookie值时不建议存储敏感信息比如密码 Cookie 在django的代码中，我们可以使用一些提供Response响应的类，如：HttpResponse，redirect等实例的内置set_cookie函数来进行django项目中的Cookie设置 set_cookie(key, value=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;,domain=None, secure=False, httponly=False) key：Cookie的key值，未来通过该key值获取到对应设置好的Cookie。 value=&#39;&#39;：对应Cookie的key值的value，比如：set_cookie(key=&#39;value&#39;,value=&#39;shuai&#39;) max_age=None：Cookie生效的时间，单位为秒，如果Cookie值只持续在客户端浏览器的会话时长，那么这个值应该为None。存在该值时，expires会被计算得到。 expires=None：Cookie具体过期日期，是一个datetime.datetime对象，如果该值存在，那么max_age也会被计算得到 1234import datetimecurrent_time = datetime.datetime.now() # 当前时间expires_time = current_time + datetime.timedelta(seconds=10) # 向后推延十秒set_cookie('key','value',expires=expires_time) #设置Cookie及对应超时时间 path=&#39;/&#39;：指定哪些url可以访问到Cookie，默认/为所有。 domain=None：当我们需要设置的为一个跨域的Cookie值，那么可以使用该参数，比如：domain=&#39;.test.com&#39;，那么这个Cookie值可以被www.test.com、bbs.test.com等主域名相同的域所读取，否则Cookie只被设置的它的域所读取。为None时，代表当前域名下全局生效。 secure=False：https加密传输设置，当使用https协议时，需要设置该值，同样的，如果设置该值为True，如果不是https连接情况下，不会发送该Cookie值。 httponly=False：HTTPOnly是包含在HTTP响应头部中Set-Cookie中的一个标记。为一个bool值，当设置为True时，代表阻止客户端的Javascript访问Cookie。这是一种降低客户端脚本访问受保护的Cookie数据风险的有效的办法 设置COOKIE 简单的实现一下COOKIE的设置 12345678from django.shortcuts import render,HttpResponse# Create your views here.def set_cookie(request): # 在HTTPResponse部分设置COOKIE值 cookie_reponse = HttpResponse('这是一个关于cookie的测试') cookie_reponse.set_cookie('test','hello cookie') return cookie_reponse 以上视图函数返回一个HttpResponse对象，并在该对象中集成COOKIE值的设定，设置key值为test，value值为hello cookie 获取COOKIE 再来简单的实现一下COOKIE的获取 1234def get_cookie(request): # 获取cookie值，从request属性中的COOKIE属性中 cookie_data = request.COOKIES.get('test') return HttpResponse('Cookie值为:%s' % cookie_data) Cookie值存储在，request中的COOKIES属性中 并且该属性获取到的结果与字典类似，直接通过内置函数get获取即可 删除COOKIE 这里通过该视图函数路由进行COOKIE的删除 1234def delete_cookie(request): response = HttpResponseRedirect('/check_cookie/') response.delete_cookie('test') return response delete_cookie(key, path=&#39;/&#39;, domain=None) 在Cookie中删除指定的key及对应的value，如果key值不存在，也不会引发任何异常。 由于Cookie的工作方式，path和domain应该与set_cookie时使用的值相同，否则Cookie值将不会被删除 通过response相应类的delete_cookie方法，本来应该在会话结束之后才消失的Cookie值，现在已经被直接删除掉。后台中通过Request中的Cookie字典获取到值也为None 不要忘记字典的get，获取不到结果时，返回None 但是，现在还有一个问题，我们在用户浏览器存储的Cookei值为明文，具有极大的安全隐患，django也提供了加密的Cookie值存储及获取方式 防止篡改COOKIE 通过set_signed_cookie函数进行持有签名的COOKIE值设置，避免用户在客户端进行修改 要记得，这个函数并不是对COOKIE值进行加密 HttpResonse.set_signed_cookie(key, value, salt=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;, domain=None, secure=None, httponly=True) 为cookie值添加签名，其余参数与set_cookie相同 Request.get_signed_cookie(key, salt=&#39;&#39;, max_age=None) 从用户请求中获取通过salt盐值加了签名的Cookie值。 这里的salt要与之前存储时使用的salt值相同才可以解析出正确结果。 还要注意的是，如果对应的key值不存在，则会引发KeyError异常，所以要记得异常捕获来确定是否含有Cookie值 123456789def check_salt_cookie(request): try: salt_cookie = request.get_signed_cookie(key='salt_cookie',salt='nice') except KeyError: #获取不到该key值的Cookie response = HttpResponse('正在设置一个salt Cookie值') response.set_signed_cookie(key='salt_cookie',salt='nice',value='salt_cookie') return response else: #获取到了对应key值，展示到新的HttpResonse中 return HttpResponse('获取到的salt Cookie值:%s' % salt_cookie) 第一次访问的时候，还没有加Cookie值，所以我们在获取的时候会抛出KeyError异常 此时捕获异常，并且设置Cookie即可； 再次刷新的时候，因为这里已经给出了Cookie值，则不会引发异常，会在页面中展示获取到的加盐Cookie Session 虽然说有了Cookie之后，我们把一些信息保存在客户端浏览器中，可以保持用户在访问站点时的状态，但是也存在一定的安全隐患，Cookie值被曝露，Cookie值被他人篡改，等等。我们将换一种更健全的方式，也就是接下来要说的Session。 Session在网络中，又称会话控制，简称会话。用以存储用户访问站点时所需的信息及配置属性。当用户在我们的Web服务中跳转时，存储在Session中的数据不会丢失，可以一直在整个会话过程中存活。 在django中，默认的Session存储在数据库中session表里。默认有效期为两个星期。 session创建流程 客户端访问服务端，服务端为每一个客户端返回一个唯一的sessionid，比如xxx。 客户端需要保持某些状态，比如维持登陆。那么服务端会构造一个{sessionid: xxx }类似这样的字典数据加到Cookie中发送给用户。注意此时，只是一个随机字符串，返回给客户端的内容并不会像之前一样包含实际数据。 服务端在后台把返回给客户端的xxx字符串作为key值，对应需要保存的服务端数据为一个新的字典，存储在服务器上，例如：{xxx : {id:1}} 之后的一些客户端数据获取，都是通过获取客户端向服务端发起的HttpRequest请求中里Cookie中的sessionid之后，再用该sessionid从服务端的Session数据中调取该客户端存储的Session数据 注意：补充说明，默认存储在数据库的Session数据，是通过base64 编码的，我们可以通过Python的base64模块下的b64decode()解码得到原始数据 整个过程结束之后：客户端浏览器存储的其实也只是一个识别会话的随机字符串（xxx） 而服务器中是通过这个随机的字符串（xxx:value）进行真正的存储 Session的使用必须在Settings配置下 12345678910INSTALLED_APPS = ( ... 'django.contrib.sessions', ...)MIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', ...) 当settings.py中SessionMiddleware激活后 在视图函数的参数request接收到的客户端发来的HttpResquest请求对象中都会含有一个session属性 这个属性和之前所讨论的Cookie类似，是一个类字典对象，首先支持如下常用字典内置属性 获取Session session_data = request.session.get(Key) session_data = request.session[Key] 在Session中获取对应值，get方法获取时，如不存在该Key值，不会引发异常，返回None 而第二种直接通过字典获取，如Key值不存在，引发KeyErro 删除Session del request.seesion[Key] 删除对应session，Key值不存在时，引发KeyError request.session.clear() 清空Session中的所有数据。这里客户端还会保留sessionid 只不过在服务端sessionid对应的数据没有了。 request.session.flush() 直接删除当前客户端的的Seesion数据。这里不光服务端sessionid对应的数据没有了，客户端的sessionid也会被删除 设置有效期 request.session.set_expiry(value)： 设置Session的有效时间。 value：有效时间。 为整数时：将在value为秒单位之后过期 为0时：将在用户关闭浏览器之后过期。 为None时：使用全局过期的设置，默认为两个星期，14天。 为datetime时：在这个指定时间后过期。 request.session.get_expiry_age() 返回距离过期还剩下的秒数。 request.session.clear_expired() 清除过期的Session会话。 编写一个简单的视图函数来玩耍Session吧 1234567891011121314151617from django.shortcuts import render,HttpResponseimport datetimedef set_session(request): if request.session.get('test_id'): session_data = request.session.get('test_id')# 用户拿到的的session随机字符串 session_key = request.session.session_key # 获取客户端浏览器中的SessionID值 session_expire = request.session.get_expiry_age() now = datetime.datetime.now() expire_time = now + datetime.timedelta(seconds=session_expire) response = '&lt;div&gt;SessionID : %s&lt;/div&gt;' % session_key + \\ '&lt;div&gt;Session : %s&lt;/div&gt;' % session_data + \\ '&lt;div&gt;ExpireTime : %s&lt;/div&gt;' % expire_time return HttpResponse(response) else: request.session['test_id'] = 'TEST' request.session.set_expiry(None) return HttpResponse('已设置好Session') 用户在第一次访问时，会走else分支，此时还没有任何服务端的Session及客户端的Cookie值设定 那么我们会通过request.session[Key]的方式来设置一个Session值，值为TEST 当用户第二次访问时将展示出所设置好的Session值及在客户端浏览器中存储的sessionid 在编写一个删除Session的视图函数吧 123456def delete_session(request): if request.session.get('test_id'): del request.session['test_id'] return HttpResponse('Session被删了') else: return HttpResponse('目前没有任何需要删除的session') 这里温柔的使用del request.session[Key]的方式来进行Session的删除 如果存在对应test_id的Session值则删除，反之返回一个字符串 Session删除总结 使用的是del的针对性删除方式，这样不会将整个客户端的session删除掉 使用request.session.clear()，只是清空了服务端Session中的数据，但是客户端的Cookie中还会保存sessionid，只不过这个值对应的字符串所对应的用户数据是一个空 使用request.session.flush()，那么客户端Cookie中保存的sessionid首先会被删除，其次服务端通过sessionid值保存的用户数据也会被全部删除。","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django的消息框架(message)与Django分页组件(paginator)","slug":"Django的消息框架(message)与Django分页组件(paginator)","date":"2019-10-21T02:10:07.945Z","updated":"2019-10-21T02:11:00.796Z","comments":true,"path":"2019/10/21/Django的消息框架(message)与Django分页组件(paginator)/","link":"","permalink":"http://laxe.top/2019/10/21/Django的消息框架(message)与Django分页组件(paginator)/","excerpt":"Messages消息框架 在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做flash message给用户 对于这个功能，Django提供基于Cookie 和会话的消息，无论是匿名用户还是认证的用户。 其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定level 标签，表示其优先级（例如info、warning 或error）","text":"Messages消息框架 在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做flash message给用户 对于这个功能，Django提供基于Cookie 和会话的消息，无论是匿名用户还是认证的用户。 其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定level 标签，表示其优先级（例如info、warning 或error） django-admin startproject 创建的默认settings.py 已经包含启用消息框架功能需要的所有的设置 INSTALLED_APPS 中的&#39;django.contrib.messages&#39;。 MIDDLEWARE_CLASSES 中的&#39;django.contrib.sessions.middleware.SessionMiddleware&#39; 和&#39;django.contrib.messages.middleware.MessageMiddleware&#39; 默认的后端存储 依赖[sessions] 所以MIDDLEWARE_CLASSES 中必须启用SessionMiddleware 并出现在MessageMiddleware 之前 TEMPLATES 设置中定义的DjangoTemplates 的&#39;context_processors&#39; 选项包含&#39;django.contrib.messages.context_processors.messages&#39; 消息级别 12&gt; from django.contrib import messages&gt; messages.debug messages.info messages.success messages.warning messages.error 使用消息框架 视图函数只需要创建messages消息对象即可 12messages.warning(request,'登陆失败，用户名或密码无效')return render(request,'login.html',locals()) 前端模板中判断是否含有messages消息，遍历取出即可 也可以结合bootstrap框架让提示消息变得更加美丽 1234567&#123;% if messages %&#125; &#123;% for message in messages %&#125; &lt;div class=\"alert alert-&#123;&#123; message.tags &#125;&#125; fade in\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125;&#123;% endif %&#125; 注意：messages对象是一个数据集，并不是单独的一条消息，需要我们在使用时，必须通过for循环进行访问 Paginator分页组件 12&gt; from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger&gt; 1Paginator ：创建分页对象 分页对象内置属性 1234567891011121314all_ = models.objects.all()p = Paginator(all_, 10)# 分页all_数据，每页显示10条数据p.count # 总数据量p.num_pages() # 分页数p.page_range() # 列表形式返回当前可有的页数 [1,2,3]page_1 = p.page(1) # 选择第一页，返回第一页数据对象page_1.object_list # 返回第一页所有数据for var in page_1: print(var)ABC... 某一页内置属性12345678page_1.number # 当前页的页码page_1.has_next() # 是否有下一页page_1.has_previous() # 是否有上一页page_1.has_other_pages() # 是否含有其他页page_1.next_page_number() # 下一页的页码page_1.previous_page_number() # 上一页的页码page_1.start_index() # 该页第一个数据的索引page_1.end_index() # 该页最后一个数据的索引 EmptyPage：取不到页面数据，抛出该异常 1234567all_ = models.objects.all()p = Paginator(all_, 10)try: list_ = p.page(page_num)except EmptyPage: #没有第page_num页 list_ = paginator.page(1) # 取不到该也数据，直接返回第一页数据 PageNotAnInteger：当页数是一个非整数类型时，抛出该异常 模板页面基本使用方式1234567891011&#123;% if topic_list.has_previous %&#125; &lt;!-- 当前页是否含有上一页 --&gt; &lt;a href=\"?page=&#123;&#123; list_.previous_page_number &#125;&#125;\"&gt;上一页&lt;/a&gt; &lt;!-- 连接传参形式传递上一页的页码ID --&gt;&#123;% endif %&#125;&#123;% if topic_list.has_next %&#125; &lt;!-- 当前页是否含有下一页 --&gt; &lt;a href=\"?page=&#123;&#123; list_.next_page_number &#125;&#125;\"&gt;下一页&lt;/a&gt; &lt;!-- 连接传参形式传递下一页的页码ID --&gt;&#123;% endif %&#125;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django-Forms-表单层","slug":"Django-Forms-表单层","date":"2019-10-21T02:09:00.549Z","updated":"2019-10-21T02:09:48.626Z","comments":true,"path":"2019/10/21/Django-Forms-表单层/","link":"","permalink":"http://laxe.top/2019/10/21/Django-Forms-表单层/","excerpt":"Forms django提供了一整套健全的机制来帮助我们自动创建对应HTML中的表单，类似序列化器 开发者可以方便的使用已经设定好的一系列字段进行表单的设计 可以在某个app下面新建一个forms.py文件，在这个文件编写django自带表单类的编写 比如像下面这样","text":"Forms django提供了一整套健全的机制来帮助我们自动创建对应HTML中的表单，类似序列化器 开发者可以方便的使用已经设定好的一系列字段进行表单的设计 可以在某个app下面新建一个forms.py文件，在这个文件编写django自带表单类的编写 比如像下面这样 123from django import formsclass TestForm(forms.Form): name = forms.CharField(label='名字:',max_length=100) 在这个表单类中，设置了一个CharField字段，并且具有label标签值为name 此外在&lt;input&gt;标签处还会设置maxlength=100的属性 django在接收到这样表单内的数据时，还将验证数据的长度 实例化该类，然后打印出来查看效果 1&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;名字:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type=\"text\" name=\"name\" maxlength=\"100\" required id=\"id_name\" /&gt;&lt;/td&gt;&lt;/tr&gt; 在渲染后的结果中不包含提交的按钮，以及外层的form标签，还需要我们自己手动在模板页面中进行添加 form表单实例的使用也非常简单，直接在模板页面处将表单实例以模板变量形式传递赋值即可 12345678910# views.pydef index(request): form = forms.TestForm() return render(request,'index.html',locals())&lt;!-- index.html --&gt;&lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form &#125;&#125; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; is_valid 每一个form类的实例都具有一个is_valid()方法，验证表单内的字段是否合法，并将表单中合法的的数据将放到表单中的cleaned_data属性中 如果全部数据都没有问题，那么该函数将会返回True，返回的合法数据。结果是一个字典的数据类型 123456789101112form = TestFrom()if form.is_valid(): data = form.cleaned_datadef post_test(request): if request.method == \"POST\": form = TestForm(request.POST) if form.is_valid(): name = form.cleaned_data.get('name') return HttpResponse('OK') else: form = TestForm() return render(request, \"xxx.html\",&#123;\"form\":form&#125;) 在视图函数中，当用户以post形式提交数据，此时将post数据与表单类进行关联 使用post数据做为类实例化的参数，这种操作也叫作绑定数据到表单 如果用户在表单中填写张三并提交，那么绑定数据之后的表单实例像是这样 12&lt;label for=\"id_name\"&gt;名字:&lt;/label&gt;&lt;input id=\"id_name\" maxlength=\"100\" name=\"name\" type=\"text\" value=\"张三\" /&gt; input标签中的value值为用户post所提交的数据 如果绑定数据的表单实例经过is_valid函数校验并通过，那么正确的数据将存储在cleaned_data中，cleaned_data中的数据同时也是处理好的Python数据类型，比如这里为一个字典数据类型 接下来在视图函数中可以直接通过字典的操作方式来获取到用户在对应表单标签中所填写的数据 表单字段类型 所有表单字段Field的子类均带有默认参数require BooleanField 控件：CheckboxInput 复选框：&lt;input type=&#39;checkbox&#39; ...&gt; 空值：False 12&gt; Python`：`True\\False&gt; 错误键：required CharField 控件：TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：空字符串 12&gt; Python`：`str&gt; 错误键：max_length、min_length、required ChoiceField 控件：Select 选择框：&lt;select&gt;&lt;option ...&gt;...&lt;/select&gt; 空值：空字符串 Python：Unicode str 必选参数：choices，该参数为一个二元组组成的可迭代对象，二元组中的第一个值为获取到的数据，第二个值为表单中展示的内容。 错误键：required、invalid_choice 123456class TestForm(forms.Form): choices = ( ('0','男'), ('1','女'), ) gender = forms.ChoiceField(choices=choices) DateField 控件：DateInput 日期以普通的文本框输入：&lt;input type=&#39;text&#39; ...&gt; 空值：None Python：datetime.date 验证是否为一个指定日期格式的字符串 错误键：required、invalid 可选参数：input_formats，一个时间格式化字符串，用来将表单中的数据转换为datetime.date对象 可选参数格式参考如下： 123'%Y-%m-%d', # '2006-10-25''%m/%d/%Y', # '10/25/2006''%m/%d/%y' # '10/25/06' DateTimeField 控件：DateTimeInput 日期/时间以普通的文本框输入：&lt;input type=’text’ …&gt; 空值：None Python：datetime.datetime 验证是否为一个指定日期格式的字符串 可选参数：input_formats，一个时间格式化字符串，用来将表单中的数据转换为datetime.datetime对象 错误键：required、invalid DecimalField 控件：当Field.localize 是False 时为NumberInput，否则为TextInput 123&gt; NumberInput`文本输入：`&lt;input type=\"number\" ...&gt;&gt; TextInput`文本输入：`&lt;input type=\"text\" ...&gt;&gt; 空值：None Python：decimal 验证给定值是否为一个十进制数字 可选参数：max_value、min_value控制大小值范围 max_digits：值允许的最大位数（小数点之前和之后的数字总共的位数，前导的零将被删除） decimal_places：允许的最大小数位 错误键：required，invalid， max_value， min_value， max_digits， max_decimal_places max_whole_digits EmailField 控件：文本输入：&lt;input type=&quot;email&quot; ...&gt; 空值：空字符串 Python：Unicode str 使用正则验证给定的值是否为一个合法的邮件地址 可选参数：max_length与min_length，限定邮件地址字符串大小长度。 错误键：required、invalid FileField 控件：ClearableFileInput 文件上传输入：&lt;input type=&#39;file&#39; ...&gt; 空值：None Python：UploadedFile 验证非空的文件数据绑定到表单 使用该字段时，在使用表单实例获取上传文件数据时，表单标签中需要具备enctype=&quot;multipart/form-data&quot;属性，此外还需要绑定文件数据在表单上 1form = TestForm(request.POST,request.FILES) FloatField 控件：当Field.localize是False 时为NumberInput，否则为TextInput NumberInput文本输入：&lt;input type=&quot;number&quot; ...&gt; TextInput文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：None Python：Float 验证给出的值是一个浮点数，对比float函数 可选参数：max_value、min_value限定大小值范围 错误键：required， invalid， max_value，min_value ImageField 控件：ClearableFileInput 文件上传输入：&lt;input type=&#39;file&#39; ...&gt; 空值：None Python：UploadedFile 验证文件数据并且检验是否是一个可以被pillow所解释的图像 使用该字段，需要安装pillow模块。 错误键：required，invalid，missing，empty，invalid_image IntergerField 控件：当Field.localize 是False时为NumberInput，否则为TextInput NumberInput文本输入：&lt;input type=&quot;number&quot; ...&gt; TextInput文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：None Python：int 验证给定的值是否是一个整数 可选参数：max_value、min_value限定大小值范围 错误键：required，invalid，max_value，min_value GenericIPAddressField 控件：TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：空字符串 Python：Unicode str 可选参数 protocol：默认值为both，可选IPv4或IPv6。 错误键：required，invalid MultipleChoiceField 控件：SelectMultiple &lt;select multiple=&#39;multiple&#39;&gt;...&lt;/select&gt; 空值：一个空列表 Python：list 验证表单中的值是否存在于选择列表中，对比ChoiceField，该字段支持多选 必选参数：choices，与ChoiceField类似，接收一个二元组可迭代对象 错误键：required，invalid_choice，invalid_list RegexField 控件：TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：空字符串 Python：Unicode str 验证表单中值与某个正则表达式匹配 必选参数：regex，字符串或编译的正则表达式 可选参数：max_length、min_length 错误键：required，invalid SlugField 控件：TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：空字符串 Python：Unicode对象 验证给定的值为字母、数字、下划线及连字符组成 错误键：required，invalid URLField 控件：TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：空字符串 Python：Unicode对象 验证给定值是一个有效的URL 可选参数：max_length、min_length 错误键：required，invalid TimeField 控件：TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; 空值：None Python：datetime.time 验证给定值是否为一个给定格式的时间字符串 可选参数：input_formats，控制表单输入的格式 表单属性 required： 表单字段为必填值，当传递数据为一个空值，不管是空字符串还是None 在表单验证时，将引发ValidationError异常，这个异常将会在表单上展示错误信息 label 指定当前字段的label标签值，字段默认Label为字段名所有下换线转换为空格 且一个字母大写生成 label_suffix 修改label提示字符串的追加符号，默认表单类实例化过程会自动在label属性后加: initial 字段的初始值。不能将初始值直接作为参数传入，会造成直接验证表单数据而报错。 1form = forms.TestForm(initial=&#123;'name':'Bob'&#125;) widget 表单字段渲染时使用的Widget类，如果不想使用默认的表单类型，通过该参数指明所需表单控件 可以使用类似的表单类型，在下面会有详细的介绍。 help_text 指定字段的描述文本，该文本一般会紧挨着字段显示 表单控件：widget 默认django会为每一个表单字段设置默认的HTML控件 控件用来渲染HTML中输入元素与提取提交的原始数据 如果你希望使用一个不同的控件Widget，可以为字段设置widget参数 1234from django import formsclass CommentForm(forms.Form): comment = forms.CharField(widget=forms.Textarea)#修改CharField默认控件TextInput为Textarea 此外，我们还可以为字段的Widget设置额外的属性 比如一些之后在HTML渲染时候将会使用到的标签class值等等 只需要在widget参数部分使用attrs形参指定即可，该参数设置这个字段控件的对应HTML属性 1234name = forms.CharField( max_length=5, widget=forms.TextInput(attrs=&#123;'class':'green'&#125;)) 还可以使用日期控件覆盖默认日期控件 1234567YEARS = ('2016', '2017', '2018')MONTHS = &#123; 1:'一月', 2:'二月', 3:'三月', 4:'四月',5:'五月', 6:'六月', 7:'七月', 8:'八月',9:'九月', 10:'十月', 11:'十一月', 12:'十二月'&#125;birth_year = forms.DateField(widget=froms.SelectDateWidget(years=YEARS,months=MONTHS)) 文本输入控件 TextInput 文本输入：&lt;input type=&quot;text&quot; ...&gt; NumberInput 文本输入：&lt;input type=&quot;number&quot; ...&gt; EmailInput 文本输入：&lt;input type=&quot;email&quot; ...&gt; URLInput 文本输入：&lt;input type=&quot;url&quot; ...&gt; PasswordInput 密码输入：&lt;input type=&#39;password&#39; ...&gt; HiddenInput 隐藏输入：&lt;input type=&#39;hidden&#39; ...&gt; DateInput 日期以普通的文本框输入：&lt;input type=&#39;text&#39; ...&gt; 可选参数：format，时间的字符串格式 DateTimeInput 日期/时间以普通的文本框输入：&lt;input type=&#39;text&#39; ...&gt; 可选参数：format，时间的字符串格式 TimeInput 时间以普通的文本框输入：&lt;input type=&#39;text&#39; ...&gt; 可选参数：format，时间的字符串格式 Textarea 文本区域：&lt;textarea&gt;...&lt;/textarea&gt; 选择和复选框 CheckboxInput 复选框：&lt;input type=&#39;checkbox&#39; ...&gt; 可选参数：check_test 这个参数接收一个函数对象，函数对象的参数为当前CheckboxInput的值，函数对象如果返回True，该控件在字段渲染时自动勾上。 1comment = forms.CharField(widget=forms.CheckboxInput(check_test=lambda *arg: True)) Select 单选框：&lt;select&gt;&lt;option ...&gt;...&lt;/select&gt; 可选参数：choices，与字段设置相同，但是会被字段设置所覆盖。 NullBooleanSelect 单选框：选项为Unknown、Yes和No，Unknown也代表False。 SelectMultiple 多选框：&lt;select multiple=&#39;multiple&#39;&gt;...&lt;/select&gt; RadioSelect 单选框，与select类似，但是会将选择渲染为一个单选按钮列表 CheckboxSelectMultiple 多选框：与SelectMultiple类似，但是会渲染为一个复选框列表/ 复合控件 SelectDateWidget 封装了三个Widget，分别用于年、月、日 可选参数：可以来指定日期表单的选择 years：一个列表或元组的序列数据类型，用来确定年的选择。 months：一个字典数据类型，字典的key值为月份数字，从1开始，value值为在表单中渲染展示的字符串，比如 12345MONTHS = &#123; 1:'一月', 2:'二月', 3:'三月', 4:'四月', 5:'五月', 6:'六月', 7:'七月', 8:'八月', 9:'九月', 10:'十月', 11:'十一月', 12:'十二月'&#125; 表单API 表单类的实例，只有两种，一种是绑定了数据的，一种是未绑定的。都可以渲染成为html Form.is_valid() 对于绑定了数据的表单，进行验证并返回一个数据是否合法的布尔值 并在所有数据有效时将数据放入cleaned_data中 Form.is_bound() 区分绑定表单和未绑定表单，当表单类绑定数据时，返回True Form.errors 当验证发生错误时的错误信息的字典，字典key值为字段名称，value为报错信息列表，可能有多个报错 表单的数据将会在调用is_valid时或访问errors属性时验证 并且验证过程只会调用一次，不论访问errors和调用is_valid多少次 12345678class TestForm(forms.Form): name = forms.CharField(max_length=5,) email = forms.EmailField(required=True) def clean_name(self): cleaned_data = super(TestForm,self).clean() if self.cleaned_data.get('name') == '小红': raise forms.ValidationError(\"不允许小红\") return cleaned_data 123&gt;&gt;&gt; f = forms.TestForm(&#123;'name':'小红','emali':'123'&#125;)&gt;&gt;&gt; a.errors&#123;'name': ['不允许小红'], 'email': ['This field is required.']&#125; Form.errors.as_data 返回报错信息的字典，映射字段报错信息到一个ValidationError实例 12345&gt;&gt;&gt; f.errors.as_data()&#123; 'name': [ValidationError(['不允许小红'])], 'email': [ValidationError(['This field is required.'])]&#125; Form.errors.as_json(escape_html=False) 以json格式返回错误信息 12345&gt;&gt;&gt; a.errors.as_json()'&#123; \"name\": [&#123;\"message\": \"\\\\u4e0d\\\\u5141\\\\u8bb8\\\\u5c0f\\\\u7ea2\", \"code\": \"\"&#125;], \"email\": [&#123;\"message\": \"This field is required.\", \"code\": \"required\"&#125;]&#125;' Form.initial 声明当前表单类的默认数据，参数为一个字典数据类型 key对应需要填充默认数据的表单字段，value值为实际数据 12class TestForm(forms.Form): name = forms.CharField(max_length=5,initial='Jack',) 1234567&gt;&gt;&gt; f = TestForm(initial=&#123;'name':'Bob'&#125;)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" value=\"Bob\" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt; Form.has_changed() 检查表单当前的数据是否与默认值不同 123&gt;&gt;&gt; f = TestForm(data=&#123;'name':'Jack'&#125;,initial=&#123;'name':'Bob'&#125;)&gt;&gt;&gt; f.has_changed()True Form.cleaned_data 在对绑定数据的表单实例进行is_valid验证之后，如果数据无误 那么返回的数据将保存在cleaned_data中 如果有部分数据没有经过验证，那么cleaned_data中也会保留合法的字段 并且，在cleaned_data属性中获取到的数据，只包含表单类中含有的字段 1234class TestForm(forms.Form): name = forms.CharField(max_length=5,) email = forms.EmailField(required=True) active = forms.BooleanField() 1234567891011&gt;&gt;&gt; data = &#123;... 'name':'Jack', ... 'email':'111',... 'active':True,... &#125;&gt;&gt;&gt;&gt;&gt;&gt; f = TestForm(data=data)&gt;&gt;&gt; f.is_valid()False&gt;&gt;&gt; f.cleaned_data&#123; 'name':'Jack', 'active': True&#125; Form.as_p() 将表单渲染为一系列的&lt;p&gt;标签，每个标签内含一个字段 12class TestFrom(forms.Form): name = forms.CharField(max_length=5) 123&gt;&gt;&gt; f = TestForm()&gt;&gt;&gt; print(f.as_p())&lt;p&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt; &lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/p&gt; Form.as_ul() 渲染表单为一系列的&lt;li&gt;标签，并且不包含&lt;ul&gt;标签，可以自行指定&lt;ul&gt;的HTML属性 12&gt;&gt;&gt; print(f.as_ul())&lt;li&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt; &lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/li&gt; Form.as_table() 渲染表单为&lt;tr&gt;&lt;th&gt;标签 12&gt;&gt;&gt; print(f.as_table())&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/td&gt;&lt;/tr&gt; 配置表单元素的HTML id值与默认自带的label标签 通过表单类进行渲染时，默认会包含以下属性 表单元素的HTML id属性 辅助的label标签 有些时候，想要设置自定义HTML id值或者取消label标签，可以使用如下内置函数 Form.auto_id=True 修改对应渲染表单属性 当auto_id值为False时，表单类的渲染将不会包含&lt;label&gt;以及id属性 123&gt;&gt;&gt; f = TestForm(auto_id=False)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/td&gt;&lt;/tr&gt; 模板中表单实例属性 模板页面接收到的form表单实例支持循环遍历访问 123&#123;% for field in form %&#125; &#123;&#123; field &#125;&#125;&#123;% endfor %&#125; 其中for迭代访问之后的每一个表单字段又支持如下操作 ``：字段的label，例如Email address。 ``：包含在HTML 标签中的字段值。 ``：这个字段的ID值。 ``：字段的值 ``：该字段的标签中name属性使用的值。 ``：该字段的帮助文档。 ``：字段的验证错误信息，字段标签会在 ``：如果该字段为隐藏字段，返回True。反之返回False。 ``：获取当前字段实例，可以用该属性来访问字段实例的属性 1&#123;&#123; field.field.max_length &#125;&#125; 与模型类关联的表单 除了以上我们自定义表单类来进行表单的初始化 django还提供了另外一种表单类的创建方法，可以通过与模型关联来构建表单 这种办法可以更加省时省力，直接使用模型类中已经定义好的字段来进行表单字段的生成 1234567class TestTable(modes.Model): name = models.CharField(max_length=10) class TestTableForm(forms.ModelForm): class Meta: model = TestTable fields = ['name'] 生成的表单实例将具备模型类中的字段，表单生成的字段顺序也与模型类中的定义顺序相同 fields属性用来显示的设置所有需要在表单中处理的字段 也可以直接为该字段设置fields = &#39;__all__&#39;来使用所有模型类中的字段作为未来的表单字段 注意 ： 如果模型类中字段定义了blank=True，那么对应关联的表单类中字段会默认具有require=False的属性 模型类中字段的verbose_name属性对应关联表单类字段的Label属性 如果模型类字段中设置了choices值，那么对应关联表单字段的widget将会设置为select 当然，除了根据关联模型类来创建表单类，还可以在关联表单类中选择性的覆盖某些字段的设置 比如使用表单类Meta元类中的widgets属性可以以字典形式设置对应字段的控件 12345678class TestTableForm(forms.ModelForm): name = forms.URLField() class Meta: model = TestTable fields = ['name'] widgets = &#123; 'name':forms.Textarea(attrs=&#123;'class':'green'&#125;) &#125; 除此之外，还可以指定labels、help_texts和error_messages等信息 1234567891011121314151617class TestTableForm(forms.ModelForm): name = forms.URLField() class Meta: model = TestTable fields = ['name'] labels = &#123; 'name':'您的名字' &#125; help_texts = &#123; 'name':'请输入您的名字' &#125; error_messages = &#123; 'name':&#123; 'required':'你必须填写这个名字', 'max_length':'你的名字太长了' &#125; &#125; 与模型关联的表单验证 表单的验证在我们调用is_valid函数时执行，也可以通过访问errors属性或调用full_clean函数 验证的出错会引发ValidationError异常，该异常会向表单传达一个错误信息 验证的步骤主要分为两步，表单验证，如果关联了模型，则还会进行模型验证 表单字段的验证分为以下过程 字段to_python，这个方法将字段的值根据字段的类型转换为Python中的数据类型，如果不能转换则引发ValidationError异常 字段的clean函数，该函数用来运行对应的验证器，根据顺序执行to_python，validate特异性验证，以及run_validators（用于将错误信息汇总）验证，如果有任何验证过程引发了ValidationError异常，验证都将停止。其余通过验证的字段数据插入到表单的cleaned_data字典中 表单中的字段clean函数，这个验证用于完成特定属性，与表单字段类型无关；比如我们经常需要验证用户输入的字段值不能为小红，那么可以编写字段的clean函数，函数命名为clean_&lt;fields_name&gt;，fileds_name为字段名 123456class TestTableForm(forms.ModelForm):def clean_name(self): name = self.cleaned_data.get('name') if name == '小红': raise forms.ValidationError('不允许小红') return name 表单的clean函数，这个方法进行表单中多个字段值的联合验证，验证之后的数据返回为cleaned_data，可以通过重写该函数来提供的额外验证方法，并且为了维持clean方法的验证行为，在代码中，表单类需要调用父类的clean方法 123456def clean(self): cleaned_data = super(TestTableForm,self).clean() name = cleaned_data.get('name') if '1' in name: cleaned_data['name'] = name.replace('1','一') return cleaned_data 最后总结的来说： 一个表单在验证时，首先验证每一个字段，接着调用字段的clean_fields函数，最后使用表单类的clean函数进行验证 如果表单与模型关联，那么现在还有第二步验证，模型的验证 模型的验证为如下过程 验证关联模型的字段及相关属性：Model.clean_fields(exclud=None)，该方法将验证模型的所有字段属性，如果有字段验证错误，引发ValidationError异常 验证模型的完整性：Model.clean(exclude=None)，可以对模型做整体的检验，如果想要自己验证模型中通过属性校验的数据，可以在模型类中重新定义这个函数 123456from django.core.exceptions import ValidationErrorclass TestTable(models.Model): name = models.CharField(max_length=10,verbose_name='名字',unique=True) def clean(self): if '$' in self.name: raise ValidationError('无法使用$符号') 验证模型的唯一性：Model.validate_unique(exclude=None)，如果模型中所有唯一约束性，比如使用类似unique属性，会校验表单中的值是否唯一 并且，除了通过绑定模型的表单实例is_valid函数可以来进行以上的验证过程，如果想自己控制验证 可以直接使用模型的full_clean(exclude=None,validate_unique=True)方法进行以上三个步骤的验证 与模型关联的表单保存 与模型关联的表单，在校验成功之后，表单实例可以直接通过save函数来进行表单数据的保存数据库 123456def form_test(request): if request.method == \"POST\": form = TestTableForm(request.POST,request.FILES) if form.is_valid(): form.save() return HttpResponse('OK:%s' % value) 该函数也支持在模型类中进行重写，但是要切记使用父类的save方法，确保数据可以正确存储到数据库中 12345def save(self, *args, **kwargs): if self.name == 'abc': return False#不做存储 else: super(TestTable,self).save(*args, **kwargs)","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django的CBV类视图","slug":"Django的CBV类视图","date":"2019-10-21T02:07:49.040Z","updated":"2019-10-21T02:08:32.370Z","comments":true,"path":"2019/10/21/Django的CBV类视图/","link":"","permalink":"http://laxe.top/2019/10/21/Django的CBV类视图/","excerpt":"CBV CBV（class base views） 就是在视图里使用类处理请求 之前的代码中，我们的视图函数都是通过函数来进行request的响应以及response的返回，并且通常我们需要判断的请求方式get或是post都需要我们在代码中通过if进行条件判断，这样的视图功能编写就叫做FBV","text":"CBV CBV（class base views） 就是在视图里使用类处理请求 之前的代码中，我们的视图函数都是通过函数来进行request的响应以及response的返回，并且通常我们需要判断的请求方式get或是post都需要我们在代码中通过if进行条件判断，这样的视图功能编写就叫做FBV 但现在在django中还提供了一种方式叫做CBV，在类中编写视图功能， 并且将传统的get、post判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样 1234567891011from django.views import Viewclass ArticleView(View): def get(self,request): raise Http404 def post(self,request): if request.is_ajax(): id_ = request.POST.get('id_') result = models.Article.objects.get(id=id_).content data = result.replace('\\r\\n','&lt;br&gt;') return HttpResponse(json.dumps(data,ensure_ascii=False) ) raise Http404 通过将请求类型定义为函数，可以更加方便进行请求方式判断 用户访问时，会经由View基类中的as_view -&gt; dispatch进行判断，通过请求类型分发到不同对应请求的函数名下；也就是通过get方式访问，那么对应会调用到名为get的函数 此外，类中函数必须为小写， 对应路由此时设置为，需要使用试图类的as_view函数进行实例化 12#url.pypath('article/',ajaxviews.ArticleView.as_view()) 通过类视图可以方便我们进行请求条件的判断 并且可以在进行接口开发时，实现同一资源路由在使用不同请求访问时的功能解耦和 意思就是不用再把所有的功能都堆到一个视图函数里啦。多方便！ 并且，在Django-Restframework框架中，也将频繁使用CBV形式进行视图编写 类视图装饰器 在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器 需要使用method_decorator将其转换为适用于类视图方法的装饰器 12&gt; from django.utils.decorators import method_decorator&gt; 全部装饰 1234567891011121314151617from django.views import Viewfrom django.utils.decorators import method_decoratordef my_decorator(func): def nei(request): # dispatch函数有参数request print('这是装饰器在调用') return func(request) return nei@method_decorator(my_decorator, name='dispatch')# 为全部请求方法添加装饰器class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为部分装饰，只需要通过method_decorator方法的name参数选择装饰的函数名即可 123456789@method_decorator(my_decorator, name='post')class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为特定的多个类视图函数进行装饰，只需要在每个函数上使用method_decorator装饰器即可 1234567class DemoView(View): @method_decorator(my_decorator) # 为get方法添加了装饰器 def get(self, request): return HttpResponse('ok') @method_decorator(my_decorator) # 为post方法添加了装饰器 def post(self, request): return HttpResponse('ok') 类视图csrf_token装饰 当类视图需要允许跨站提交数据时，使用csrf_exempt装饰器装饰函数可以被跨域访问 但是使用上面的方法进行csrf_exempt是不行的，需要在类视图基类的dispatch函数上进行装饰 123456789101112from django.views.decorators.csrf import csrf_exempt#@method_decorator(csrf_exempt,name='dispatch') # 直接加载类视图上也是可以修饰的class DemoView(View): @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): return super(DemoView,self).dispatch(request, *args, **kwargs) def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') csrf装饰只能在类视图的dispatch函数上才能被生效 除了在类视图的dispatch函数上进行装饰，在路由映射处使用csrf_exempt函数修饰路由规则也是可以的 123456#urls.pyfrom django.views.decorators.csrf import csrf_exempturlpatterns = [ ... path('',csrf_exempt(ajaxviews.DemoView.as_view()))]","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Ajax及Axios异步请求，接口数据序列化处理","slug":"Ajax及Axios异步请求，接口数据序列化处理","date":"2019-10-21T02:06:42.088Z","updated":"2019-10-21T02:07:27.363Z","comments":true,"path":"2019/10/21/Ajax及Axios异步请求，接口数据序列化处理/","link":"","permalink":"http://laxe.top/2019/10/21/Ajax及Axios异步请求，接口数据序列化处理/","excerpt":"Ajax ajax可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些 同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求 异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求","text":"Ajax ajax可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些 同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求 异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求 json数据类型 数据在键值对中 数据由逗号分隔 花括号存储数据 方括号保存数组 12345[ &#123; \"name\":\"Bill\", \"age\":1 &#125;, &#123; \"name\":\"George\", \"age\":2 &#125;, &#123; \"name\":\"Thomas\", \"age\": 3 &#125;]; jQuery-Ajax 使用ajax进行django后台数据的异步获取，django只是提供的数据，并不承担前端页面的渲染工程 这里使用jQuery所提供的ajax方法进行异步通信 首先测试数据库中模型类定义如下： 12345678class Article(models.Model): title = models.CharField(max_length=50,verbose_name=\"标题\") author = models.CharField(max_length=20,verbose_name=\"作者\") date = models.DateField(auto_now_add=True,verbose_name=\"发表日期\") content = models.TextField(verbose_name=\"文章内容\") def __str__(self): return self.title 测试数据可由用户自行添加，非常简单 编写主页视图函数，返回所有数据库中内容 123def index(request): articles = models.Article.objects.all() return render(request,'ajax/index.html',locals()) 此处的index.html页面不光承担所有数据的渲染工作 还将负责未来ajax异步请求，获取对应文章的详细内容 index.html页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; label&#123; border: 5px outset gray; width: 150px; margin-top: 10px; &#125;&lt;/style&gt;&lt;head&gt; &#123;% load staticfiles %&#125; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ajax测试&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"&#123;% static 'js/jquery.cookie.js' %&#125;\"&gt;&lt;/script&gt; &lt;!-- 该js文件用来引入jquery所提供的获取cookie值的库 为了提取对应csrf_token--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个ajax的请求测试&lt;/h1&gt; &#123;% for article in articles %&#125; &lt;label class=\"&#123;&#123; article.id &#125;&#125;\"&gt;&#123;&#123; article.author &#125;&#125;:&#123;&#123; article.title &#125;&#125;&lt;/label&gt; &#123;% endfor %&#125; &lt;p class=\"content\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $(\"label\").click(function () &#123; $.ajax(&#123; url: '/article/', // 请求地址，对应Django某个路由映射 type: 'POST', // 请求方式 post data: &#123; 'csrfmiddlewaretoken': $.cookie('csrftoken'), // 提交数据需有当前csrf_token 防跨站请求伪造令牌 'id_': $(this).attr('class'), // 获取当前的id值 传递到视图后台 &#125;, success: function (result) &#123; var data = JSON.parse(result) // 解析获得实际字符串 $('.content').html(data) // 将内容以html形式显示到对应的p标签上 &#125; &#125;) &#125;) &#125;)&lt;/script&gt; 有了前端页面，并且ajax的请求地址为/article/，那么就需要我们定义一个视图函数返回对应的json数据，并且设置路由为/article/ 123456789101112131415161718192021#urls.pypath('ajax/',ajaxviews.index), # 首页路由path('article/',ajaxviews.article) # ajax请求路由#views.pydef article(request): if request.is_ajax(): # 判断是否为ajax请求 if request.method == \"POST\": # 为ajax的post方式请求 id_ = request.POST.get('id_') if id_: try: content = models.Article.objects.get(id=id_).content.replace('\\r\\n','&lt;br&gt;') # 这里还将获取到的文章字符串内容中的换行替换为HTML的换行标签 except models.Article.DoesNotExist: raise Http404 else: data = json.dumps(content,ensure_ascii=False,cls=JsonEncoder) # 返回get对应取到的实际属性 return HttpResponse(data) raise Http404 这里要注意的是，后端返回的数据得是序列化之后的才可以被前端js所解析，直接返回一个django model数据实例是不行的。所以需要我们视图函数对需要返回的数据进行序列化操作 对于数据的序列化操作主要有以下两种 json序列化 普通Python数据直接使用json模块进行序列化 12345content = models.Article.objects.get(id=id_).content.replace('\\r\\n','&lt;br&gt;')#这里将文章内容对应返回，之所以有replace函数，是因为文章数据是通过admin后台复制添加，需要将其中的\\r\\n换行转换为HTML可以解析的&lt;br&gt;标识符data = json.dumps(content,ensure_ascii=False)# 第二个参数是因为序列化时对中文默认使用的ascii编码，此时需要将该值设置为False，这样前端接收到时才是一个正常中文结果return HttpResponse(data) 但如果要序列化的数据中包含时间类型date 或datetime时，这种办法就会报错啦 12&gt; TypeError: Object of type date is not JSON serializable&gt; 12345678910111213class JsonEncoder(json.JSONEncoder): # 自定义json处理器 def default(self, obj): if isinstance(obj, datetime): # 如果判断到类型为datetime格式 return obj.strftime('%Y-%m-%d %H:%M:%S') # 处理为字符串类型的 (年-月-日 时:分:秒) elif isinstance(obj, date): # 如果判断到json处理数据为date类型 return obj.strftime('%Y-%m-%d') else: return json.JSONEncoder.default(self,obj) # 其他数据类型按照默认的序列化方式处理即可 使用cls指定序列化方式，即可轻松解决特殊格式没有办法被json序列化的问题 1234content = models.Article.objects.get(id=id_).datedata = json.dumps(content,ensure_ascii=False,cls=JsonEncoder)# 通过json.dumps的cls参数指明所使用的自定义序列化类return HttpResponse(data) 对应前端接收展示 12var data = JSON.parse(result) // 普通json传输方式$('.content').html(data) 如果返回的数据并不是一个单独的数据属性，那么也可以通过json进行处理，以一个数据列表的形式返回 123456content = models.Article.objects.filter(id=id_).values()# ----------------------------------------------# content = models.Article.objects.all().values()# ----------------------------------------------data = json.dumps(list(content),ensure_ascii=False,cls=JsonEncoder)return HttpResponse(data) 对应前端接收展示 12345678910111213141516171819&lt;div class=\"content\"&gt; &lt;!-- 这里用到的不是之前的p标签 而是一个div容器 --&gt;&lt;/div&gt;success: function (result) &#123; var data = JSON.parse(result)[0]['content'] $('.content').html(data.replace(/\\r\\n/g,\"&lt;br&gt;\"))&#125;// ---------------------------------------------// 如果需要展示的是所有的结果，可以通过js的for循环success: function (result) &#123; var data = JSON.parse(result) var tag = '' for (var i = 0, len = data.length; i &lt; len; i++) &#123; tag += '&lt;p&gt;' + data[i]['content'].replace(/\\r\\n/g, \"&lt;br&gt;\") + '&lt;/p&gt;' tag += '&lt;hr&gt;' &#125; $('.content').html(tag)&#125;// ---------------------------------------------- Vue-Axios 除去jQuery所提供的异步通信ajax方法 在Vue中也提供了ajax的异步通信方法，叫做Axios Axios会自动转换json数据 简单的来编写一个视图函数 get：返回当前页面 post：返回一条json数据 1234567891011121314151617181920212223window.onload = function () &#123; new Vue(&#123; el: '#content', // Vue接管的区域 data: &#123; message: '这个是表单内容', &#125;, methods: &#123; getajax() &#123; axios.get('/get_ajax/', &#123; params: &#123; // 这部分为get方式进行传参时使用的 id: 123 &#125; &#125;) .then(function (response) &#123; console.log(response) // 打印输出get方式进行ajax请求时获取到的数据 &#125;) .catch(function (error) &#123; console.log(error) // 当get方式ajax请求报错时，会进入该函数 &#125;) &#125; &#125;, &#125;)&#125; 对应的HTML页面 12345&lt;body&gt; &lt;div id=\"content\"&gt; &lt;button @click='getajax'&gt;点我发送ajax的get请求&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 后台视图函数 1234if request.method == 'GET': message = request.GET.get('message') print(message) return render(request,'axios/index.html') 当使用的是post形式获取服务端数据时，首先要注意，axios默认的提交post 数据不是普通的form-data 12&gt; axios`的`post`使用的是`request payload`方式，参数格式是`application/json;charset=UTF-8&gt; 而我们之前的表单提交数据的类型都是application/x-www-form-urlencoded，所以直接再django后台通过request.POST.get是获取不到任何数据的 解决办法，需要我们在axios提交数据时，指明提交时的头部信息 1234567891011121314151617181920212223242526window.onload = function () &#123; new Vue(&#123; el: '#content', // Vue接管的区域 data: &#123; message: '这个是表单内容', &#125;, methods: &#123; getajax() &#123; axios(&#123; method: 'post', url: '/get_ajax/', data: &#123; message:this.message, name: '张三' &#125;, headers: &#123; 'Content-Type':'application/x-www-form-urlencoded', &#125;, &#125;).then((response) =&gt; &#123; console.log(response.data) this.message = response.data &#125;) &#125; &#125;, &#125;)&#125; 虽然通过添加头部信息，可以让axios发送的数据被django后台所接收到，但是此时的数据还是有问题的 获取到的POST提交的数据被django打包成了一个QueryDict中的key值，value为空数组 导致后台按照平时的解析方式是获取不到的 解决办法也很简单，把QueryDict单独处理为一个字典 12345if request.method == 'POST': data = eval(list(request.POST.keys())[0]) # 将获取到的数据转换为字典 message = data.get('message') data = json.dumps(message + '我被服务端后台修改过') return HttpResponse(data) 接下来，当用户点击按钮时，post提交表单数据，给到django后台，后台追加字符串并返回，返回的数据被then回调函数所接收到，重新赋值给绑定的表单变量中 第二种办法，在前端vue提交数据时， serializer序列化 serializer是由django所提供的一个专门用来处理django数据对象(django model)变为序列化数据的框架 并且Django的序列化不支持单个对象，比如像objects.get获取到的数据，或是Python中的 str等数据类型 该序列化框架所提供的功能类位于django.core.serializers 12345678#views.py from django.core import serializerscontent = models.Article.objects.filter(id=id_)data = serializers.serialize('json',content,ensure_ascii=False)return HttpResponse(data)var data = JSON.parse(result)[0]['fields']['content'] // 序列化传输方式$('.content').html(data.replace(/\\r\\n/g,\"&lt;br&gt;\"))console.log(data) 总结：通过管理器的get方法获取到的是一个独立的结果，并不是一个QuerySet数据对象，也不是一个普通Python数据类型；只能对数据其中的某条属性进行json格式的处理或是将其变为列表等序列数据类型之后再进行序列化处理 serializer反序列化 序列化：serializers.serialize 反序列化：serializers.deserialize 12345from django.core import serializerscontent = models.Article.objects.filter(id=id_) # QuerySetdata = serializers.serialize('json',content,ensure_ascii=False) # strcontent = serializers.deserialize(\"json\", data)return HttpResponse(data) Ajax跨域 浏览器有一个很重要的概念：同源策略(Same-Origin Policy) 所谓同源是指，域名，协议，端口相同 不同源的客户端脚本javascript、ActionScript在没明确授权的情况下，不能读写对方的资源 同源：请求资源的地址与请求的发起方都属于同一域名下 JSONP JSONP是JSON with padding（填充式JSON 或参数式 JSON）的简写 JSONP实现跨域请求的原理简单的说，就是动态创建标签，然后利用的src不受同源策略约束来跨域获取数据。 JSONP由两部分组成：回调函数和数据 回调函数是当响应到来时应该在页面中调用的函数；回调函数的名字一般是在请求中指定的，而数据就是传入回调函数中的参数 注意：JSONP方式解决AJAX跨域，必须使用get方式，并且该方式常在一些数据量级比较小的情况下，因为需要服务端后台构建回调函数带参数的字符串，像是下面这样 123456def index(request): name = request.GET.get('name') + '哈哈哈哈哈' callback = request.GET.get('callback') data = '%s(\"%s\")' % (callback,name) # 这里以前端生成的回调函数名作为函数名，待返回数据作为参数返回 return HttpResponse(data) 前端代码：点击按钮传送表单的值到后台，并由后台处理后追加内容返回，返回的结果展示再p标签处 12345&lt;input type='text' id='ajax_data'&gt;&lt;button&gt; 按钮&lt;/button&gt;&lt;p id=\"content\"&gt;&lt;/p&gt; Ajax代码，获取当前表单数据，并使用get方式传递到服务端 12345678910111213141516$(document).ready(function () &#123; $(\"button\").click(function () &#123; $.ajax(&#123; url: 'http://127.0.0.1:8000/axios/', // 请求地址，对应Django某个路由映射 type: 'get', // 请求方式 post dataType: \"jsonp\", // 指定服务端返回的数据为jsonp格式 data: &#123; 'name': $('#ajax_data').val(), &#125;, success: function (result) &#123; console.log(result) $('#content').html(result) &#125; &#125;) &#125;)&#125;) ajax发起请求，并指定服务端返回数据类型为jsonp格式 服务端构建函数包含参数的字符串，为jsonp请求发起时，给定的回调参数名，参数为要返回的数据 客户端先会调用回调函数，然后会调用 1success 回调函数可以接收处理服务端返回的数据 success回调函数是成功返回数据后必定会调用的函数 CORS 跨域资源共享CORS(Cross-Origin Resource Sharing)是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源 当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求 注意：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信 这里需要我们将后端视图函数在接收到请求时，返回结果指明头部信息 123456789101112class Cors(View): def post(self,request): #判断是否为ajax请求 name = request.POST.get('name') response = HttpResponse(json.dumps('OK')) response[\"Access-Control-Allow-Origin\"] = \"http://127.0.0.1:5500\" # 允许可以跨域请求的站点 response[\"Access-Control-Allow-Methods\"] = \"POST, GET, OPTIONS\" # 允许可以跨域访问的请求方式 response[\"Access-Control-Allow-Headers\"] = \"*\" # 允许可以跨域请求时的头部字段 return response 前端页面的ajax代码正常提交数据即可 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id='name'&gt; &lt;button id='button'&gt;提交&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $('#button').click(function ()&#123; $.ajax(&#123; url: 'http://127.0.0.1:8000/', type: 'post', data: &#123; name: $('#name').val() &#125;, success: function(result)&#123; console.log(result) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; django-cors-headers 除了以上手动构建返回结果的头部信息用来解决跨域问题 在django中还可以通过一个先成可以自动添加CORS-Header的中间件，只需要在settings.py中做一些简单的配置即可 要想使用该中间件需要安装django的三方插件 1pip install django-cors-headers 安装完成之后，在django的settings文件中加载app 123456# settings.pyINSTALLED_APPS = [ ... 'django.contrib.staticfiles', 'corsheaders',] 接下来在中间件配置部分加载该插件所提供的中间件 1234567891011# settings.pyMIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', # 顺序需要在common组件之前 'django.middleware.common.CommonMiddleware', #'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 继续配置允许跨站请求的白名单设置等属性 12345678910111213# settings.pyCORS_ORIGIN_ALLOW_ALL = False # 是否允许其他所有站点发起跨站请求CORS_ORIGIN_WHITELIST = ( 'http://127.0.0.1:5500',) # 跨站请求白名单CORS_ALLOW_METHODS = ( 'POST',) # 允许跨站访问的请求方式CORS_ALLOW_HEADERS = ( '*',) # 允许跨站请求头中的字段类型 注：其中某些设置的默认值为如下所示 1234567891011121314151617181920default_headers = ( 'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with',)default_methods = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT',)","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django邮件发送及华丽呼哨的邮件格式","slug":"Django邮件发送及华丽呼哨的邮件格式","date":"2019-10-21T02:05:03.231Z","updated":"2019-10-21T02:05:55.339Z","comments":true,"path":"2019/10/21/Django邮件发送及华丽呼哨的邮件格式/","link":"","permalink":"http://laxe.top/2019/10/21/Django邮件发送及华丽呼哨的邮件格式/","excerpt":"发送邮件 django中内置了许多方法可以使开发者方便的进行邮件发送 邮件配置 发送邮件，首先需要在项目的settings.py文件下配置邮件服务器连接等信息 123456EMAIL_USE_SSL = 真 ＃安全套接字层安全套接层，取决于邮件服务器是否开启加密协议 EMAIL_HOST = 'smtp.qq.com' ＃邮件服务器地址 EMAIL_PORT = 465 ＃邮件服务器端口 EMAIL_HOST_USER = 'account@qq.com' ＃登陆邮件服务器的账号EMAIL_HOST_PASSWORD = '密码' ＃登陆邮件服务器的密码 DEFAULT_FROM_EMAIL = EMAIL_HOST_USER ＃邮件的发送者","text":"发送邮件 django中内置了许多方法可以使开发者方便的进行邮件发送 邮件配置 发送邮件，首先需要在项目的settings.py文件下配置邮件服务器连接等信息 123456EMAIL_USE_SSL = 真 ＃安全套接字层安全套接层，取决于邮件服务器是否开启加密协议 EMAIL_HOST = 'smtp.qq.com' ＃邮件服务器地址 EMAIL_PORT = 465 ＃邮件服务器端口 EMAIL_HOST_USER = 'account@qq.com' ＃登陆邮件服务器的账号EMAIL_HOST_PASSWORD = '密码' ＃登陆邮件服务器的密码 DEFAULT_FROM_EMAIL = EMAIL_HOST_USER ＃邮件的发送者 注意：EMAIL_HOST_PASSWORD所设置的登陆邮件服务器的密码为邮件客户端后台所设置的第三方客户端登陆密码，这个值并非直接账号密码 如：QQ邮箱的该值密码在网页版QQ邮件客户端的设置-&gt;帐户-&gt;开启POP3/SMTP服务|IMAP/SMTP服务 发送文本邮件 发送普通邮件可以使用django.core.mail模块下的send_mail函数进行 send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None) 将邮件发送至recipient_list中的每一个收件人处 subject：发送邮件标题 message：发送邮件正文 from_email：发件人邮箱地址 recipient_list：一个字符串列表，每一个数据为接收者的邮箱地址 html_message：如果指定该值，则发送的内容类型为text/html为一个html邮件内容 发送普通邮件视图函数 12345678910从 django.core.mail 导入 send_mail def send_email （请求）： subject = '邮件测试' message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' send_mail（ 主题=主题， 消息=消息， from_email ='from@qq.com'， 收件人列表= [ 'recv@qq.com'，'recv1@qq.com' ] ）return HttpResponse（'Down'） 发送HTML邮件 发送这里的邮件内容为一个HTML的a标签，但是真正接收者接到该邮件时，a标签并不会解释称为真正的a标签，只是一个普通的字符串，这是因为当前发送邮件的类型为text/plain，可以使用html_message参数进行HTML内容的发送 1234567891011从 django.core.mail 导入 send_mail def send_email （请求）： subject = '邮件测试' message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' send_mail（ subject = subject， message = ''，＃该参数为必须参数，必须填写 html_message =消息， from_email ='from@qq.com'， 收件人列表= [ 'recv@qq.com'，'recv1 @ qq。 com' ] ）返回 HttpResponse（'Down'） 发送html格式邮件还可以使用django.core.mail模块下的EmailMultiAlternatives类进行邮件体的构造，然后进行邮件发送 EmailMultiAlternatives(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None) subject：邮件标题 body：邮件内容 from_email：邮件发送者 to：邮件接收人列表 EmailMultiAlternatives.attach_alternative(content, mimetype) 向EmailMultiAlternatives实例中添加mimetype支持的邮件内容 content：添加的邮件内容 mimetype：添加内容的mime类型 EmailMultiAlternatives.send() 发送邮件 12345678910111213从 django.core.mail 导入 EmailMultiAlternatives def send_email （请求）： subject = '邮件测试' text_message = '学习Python，我很快乐' html_message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' email = EmailMultiAlternatives（ subject = subject， body = text_message， from_email ='1747266529@qq.com'，收件人 = [ 'recv@qq.com'，'recv1@qq.com' ] ） email.attach_alternative（html_message，'text / html'）＃添加HTML邮件部分 email.send（）＃发送邮件返回 HttpResponse（'Down'） 发送富文本邮件 经常需要我们在邮件中加入图片等静态资源 需要用到python中email.mime.image模块下的MIMEImage类进行图片内容的构造 这里发送邮件使用EmailMessage类，来自于django.core.mail模块下 并在使用对应该类实例的attach添加图片资源数据 最后使用实例的send函数发送邮件 EmailMessage(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None) ``subject`：邮件标题 body：邮件内容 from_email：邮件发送者 to：邮件接收人列表 123456789101112131415161718192021222324252627282930313233从 sendmailpro.settings 导入 STATICFILES_DIRS 进口 OS 从 email.mime.image 进口 MIMEImage 从 django.core.mail 进口 EmailMessage DEF SEND_EMAIL （请求）： 受试者= '图片邮件测试' file_1 = os.path.join（STATICFILES_DIRS [ 0 ]，'img / 1.png'）以 open（file_1，'rb'）作为 fp：＃：第一张图片 image_1 = MIMEImage（fp.read（）） file_2 = os.path.join（STATICFILES_DIRS [ 0 ]，' img / 2.png' ），以 open（file_2，'rb'）as fp：＃：第二张图片 image_2 = MIMEImage（fp.read（）） body = “ &lt;img src ='cid：first_id'&gt; &lt;br&gt; &lt;img src =' cid：sec_id'&gt;“ ＃发送邮件主体内容 image_1.add_header（'Content-ID'，'&lt;％s&gt;'％'first_id'）＃通过CID对称图片在邮件内容中的位置 image_2.add_header（'Content- ID'，'&lt;％s&gt;'％'sec_id'） message = EmailMessage（＃构建发送的邮件主体 subject = subject， body = body， from_email ='from@qq.com' ， to = [ 'recv@qq.com'，'recv1@qq.com' ] ） message.content_subtype = ' html'message.attach（image_1）＃添加两张图片的 message.attach（image_2） message.send（）＃发送邮件返回 HttpResponse（'Down'） 发送附件邮件 发送附件，也可以使用django.core.mail模块下的EmailMessage类进行附件邮件体构造 通过EmailMessage实例的attach|attach_file两个函数在邮件主体中添加附件内容 attach_file添加邮件附件直接加入路径即可，但是attach添加附件内容需要提供附件内容 attach(filename=None, content=None, mimetype=None) 添加附件内容 filename：附件文件名称 content：附件内容 mimetype：附件的MIME类型 attach_file(path, mimetype=None) 直接通过路径添加附件 path：附件路径 mimetype：附件的MIME类型 1234567891011121314151617181920从 sendmailpro.settings 导入 STATICFILES_DIRS 进口 OS 从 email.mime.image 进口 MIMEImage 从 django.core.mail 进口 EmailMessage DEF SEND_EMAIL （请求）： 受试者= '附件邮件测试' 电子邮件= EmailMessage（ 受试者=受试者 身体= “这是一篇具有图片附件的邮件”， from_email = 'from@qq.com'， to = [ 'recv@qq.com'，'recv1@qq.com' ] ） file_1 = os.path.join（STATICFILES_DIRS [ 0]，'img / 1.png'） image_1 =打开（file_1，'rb'）.read（） email.attach（'1.png'，image_1，'image / png'）＃使用attach实例函数添加附件内容 file_2 = os.path.join（STATICFILES_DIRS [ 0 ]，'img / 2.png '）email.attach_file（file_2，mimetype = 'image / png'）＃使用attach_file实例函数添加附件路径 email.send（）返回 HttpResponse（'Down'）","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"HayStack全文检索在Django中应用","slug":"HayStack全文检索在Django中应用","date":"2019-10-21T02:03:30.461Z","updated":"2019-10-21T02:04:17.438Z","comments":true,"path":"2019/10/21/HayStack全文检索在Django中应用/","link":"","permalink":"http://laxe.top/2019/10/21/HayStack全文检索在Django中应用/","excerpt":"全文检索官方文档 全文检索就是针对所有内容进行动态匹配搜索的概念 针对特定的关键词进行建立索引并精确匹配取出搜索结果，并且达到性能优化的目的 为啥要有全文检索 最常见的全文检索就是我们在数据库中进行的模糊查询 但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低 常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作 如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项","text":"全文检索官方文档 全文检索就是针对所有内容进行动态匹配搜索的概念 针对特定的关键词进行建立索引并精确匹配取出搜索结果，并且达到性能优化的目的 为啥要有全文检索 最常见的全文检索就是我们在数据库中进行的模糊查询 但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低 常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作 如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项 django使用啥进行全文检索 Python提供了各种模块进行全文检索，最常见的是haystack模块 该模块设计为支持whoosh、solr、Xapian、Elasticsearch四种全文检索引擎后端 使用haystack模块，不用更改代码，直接切换引擎，可以极大的减少代码量 haystack属于一种全文检索的框架 whoosh 纯Python编写的全文搜索引擎，是目前最快的python所编写的检索引擎，虽然性能比不上solr、Xapian、Elasticsearch等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，whoosh已经足够使用 solr Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎 Lucene：不是一个完整的全文检索引擎，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能 Xapian 12&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene&gt; Elasticsearch ElasticSearch是一个基于Lucene的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口 Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到实时搜索，稳定，可靠，快速，安装使用方便 中文分词 whoosh作为一个全文搜索引擎模块 分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺 可以通过Jieba模块重写分词操作，支持whoosh对中文的强大操作 安装中文分词模块 1pip install jieba 除了jieba分词，现在还有很多付费的中文分词模块 中科院计算所NLPIR ansj分词器 哈工大的LTP 清华大学THULAC 斯坦福分词器 Hanlp分词器 结巴分词 KCWS分词器(字嵌入+Bi-LSTM+CRF) ZPar IKAnalyzer 安装 首先安装HayStack框架以及whoosh搜索引擎 12pip install django-haystackpip install whoosh settings配置 添加haystack应用到项目的settings文件下的app部分 12345INSTALLED_APPS = [ 'django.contrib.admin', ... 'haystack',] 添加搜索引擎，这里使用whoosh引擎 123456789HAYSTACK_CONNECTIONS = &#123; 'default': &#123; 'ENGINE': 'haystack.backends.whoosh_cn_backend.WhooshEngine', 'PATH': os.path.join(BASE_DIR, 'whoosh_index'), &#125;&#125;#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor' 这里要注意的是，我们使用的引擎为whoosh_cn_backend 本身的whoosh引擎名为：whoosh_backend whoosh_cn_backend将在接下来我们对安装目录下的引擎文件复制修改得来 在项目的路由文件下配置查询的路由映射 12345from django.urls import include,re_pathurlpatterns = [ path('admin/', admin.site.urls), re_path('^search/',include('haystack.urls')),] 当查询条件被提交时，会跳转至search路由 并且查询条件会作为get请求时的连接参数传入，参数key值为q 创建索引文件 接下来，在需要被搜索的app下建立search_indexes.py文件，该文件名不许变更 1234567891011121314151617181920212223#app.models.pyclass User(models.Model): # 用户表 name = models.CharField( max_length=50, verbose_name='昵称' ) account = models.CharField(max_length=50,verbose_name='账号',unique=True) passwd = models.CharField(max_length=50,verbose_name='密码') def __str__(self): return self.name#app.search_indexes.pyfrom haystack import indexesfrom . import modelsclass UserIndex(indexes.SearchIndex, indexes.Indexable): text = indexes.CharField(document=True, use_template=True) def get_model(self): return models.User # 当前模型文件下需要被检索的模型类 def index_queryset(self, using=None): return self.get_model().objects.all() 该类为索引类，类名为模型类的名称+Index：比如模型类为People,则这里类名为PeopleIndex get_model函数用来获取当前索引类所关联的模型类，这里我们关联上面的User 类对象 text=indexes.CharField语句指定了将模型类中的哪些字段建立索引，而use_template=True说明后续我们将通过一个数据模板文件来指明需要检索的字段 12&gt; document=True&gt; 为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找 创建模板数据文件 创建数据模板文件 数据模板文件路径：templates/search/indexes/yourapp/note_text.txt 放在任何一个你的Django能搜索到的模板文件夹template下面均可，这个文件主要确定要检索的字段，为他们建立索引 文件名必须为要索引的类名_text.txt，比如这里我们检索的类名是User，那么对应的数据模板文件名为user_text.txt，文件名小写即可 1234#template.search.indexes.people.user_text.txt&#123;&#123; object.name &#125;&#125;&#123;&#123; object.account &#125;&#125;&#123;&#123; object.online_time &#125;&#125; 在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中name、account以及online_time字段设置索引，当检索时会对这三个字段去做全文检索 接下来创建一个搜索结果展示页面 检索结果模板页面 创建检索结果展示页面 检索结果展示页面，需要在固定的目录路径下进行模板页面的编写 路径为：templates/search/ 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% if query %&#125; &lt;h3&gt;搜索结果如下：&lt;/h3&gt; &#123;% for result in page.object_list %&#125; &#123;&#123; result.object.name &#125;&#125; &lt;br&gt; &#123;&#123; result.object.account &#125;&#125; &lt;br&gt; &#123;&#123; result.object.online_time &#125;&#125; &lt;br&gt; &#123;% empty %&#125; &lt;p&gt;没找到&lt;/p&gt; &#123;% endfor %&#125; &#123;% if page.has_previous or page.has_next %&#125; &lt;div&gt; &#123;% if page.has_previous %&#125; &lt;a href=\"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;\"&gt; 上一页 &lt;/a&gt; &#123;% endif %&#125; &#123;% if page.has_next %&#125; &lt;a href=\"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;\"&gt; 下一页 &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 这个模板页面中已经自带了分页功能，可以按照需求修改 创建检索模板页面内容 还需要有一个表单，提交检索信息 1234&lt;form method='get' action=\"/search/\" &gt; &lt;input type=\"text\" name=\"q\"&gt; &lt;input type=\"submit\" value=\"查询\"&gt;&lt;/form&gt; 这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为get，并且检索输入的表单框name属性必须为q 中文分词配置 接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局 进入到python的安装目录下，比如我的目录为：C:\\Python37\\Lib\\site-packages\\haystack\\backends 在该路径下创建名为ChineseAnalyzer.py的中文分词文件 1234567891011121314151617181920import jiebafrom whoosh.analysis import Tokenizer, Tokenclass ChineseTokenizer(Tokenizer): def __call__(self, value, positions=False, chars=False, keeporiginal=False, removestops=True,start_pos=0, start_char=0, mode='', **kwargs): t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs) seglist = jieba.cut(value, cut_all=True) for w in seglist: t.original = t.text = w t.boost = 1.0 if positions: t.pos = start_pos + value.find(w) if chars: t.startchar = start_char + value.find(w) t.endchar = start_char + value.find(w) + len(w) yield tdef ChineseAnalyzer(): return ChineseTokenizer() 在这个文件中，定义了一个ChineseAnalyzer的函数，这个函数将替代搜索引擎配置文件中的分词方式 复制引擎文件，修改分词方式为中文 同样在该文件夹下C:\\Python37\\Lib\\site-packages\\haystack\\backends，复制whoosh_backend.py文件，创建一个新的文件名为whoosh_cn_backend.py，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在settings配置文件中修改引擎为&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;, 修改该引擎配置文件中的：analyzer=StemmingAnalyzer()变为analyzer=ChineseAnalyzer() 并且要记得在头部引入刚才所编写的中文分词文件 12#whoosh_cn_backend.pyfrom .ChineseAnalyzer import ChineseAnalyzer 初始化索引 最后，初始化索引数据 1python manage.py rebuild_index","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Tinymce富文本编辑器","slug":"Tinymce富文本编辑器","date":"2019-10-21T02:02:17.921Z","updated":"2019-10-21T02:03:05.974Z","comments":true,"path":"2019/10/21/Tinymce富文本编辑器/","link":"","permalink":"http://laxe.top/2019/10/21/Tinymce富文本编辑器/","excerpt":"图文混排 在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列 在django中可以使用TimyMce富文本编辑器进行图文混排功能的实现 TinyMce TinyMCE：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成 功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持AJAX，加载速度非常快 最重要的是，TinyMCE是一个根据LGPL license发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面 配置上传路径 首先配置整个项目的上传文件路径，为了区别与自身的static静态目录 这里的上传文件我们将另外保存至upload文件夹 123&gt; #settings.py&gt; UPLOAD_ROOT = os.path.join(BASE_DIR,'upload')&gt;","text":"图文混排 在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列 在django中可以使用TimyMce富文本编辑器进行图文混排功能的实现 TinyMce TinyMCE：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成 功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持AJAX，加载速度非常快 最重要的是，TinyMCE是一个根据LGPL license发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面 配置上传路径 首先配置整个项目的上传文件路径，为了区别与自身的static静态目录 这里的上传文件我们将另外保存至upload文件夹 123&gt; #settings.py&gt; UPLOAD_ROOT = os.path.join(BASE_DIR,'upload')&gt; 配置模板页面 首先需要在使用到tinymce富文本编辑器的html页面下导入必备js文件 12345&gt; &lt;script src=\"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;\" &gt;&lt;/script&gt;&gt; &lt;script src=\"&#123;% static 'js/tinymce_setup.js' %&#125;\"&gt;&lt;/script&gt;&gt; &gt; &lt;script src=\"&#123;% static 'tinymce/js/tinymce/tinymce.min.js' %&#125;\"&gt;&lt;/script&gt;&gt; 接下来，在模板页面中加入一个id为content的输入表单，这里我们以一个文章数据为例 首先是模型层文件定义 123456&gt; #models.py &gt; class Article(models.Model):&gt; title = models.CharField(max_length=100,verbose_name='标题')&gt; author = models.CharField(max_length=100,verbose_name='作者')&gt; content = models.TextField(verbose_name='内容')&gt; 这里的content内容要用到富文本编辑器 接着是模板页面的主要部分 1234567891011&gt; &lt;form method=\"POST\" action='/' enctype=\"multipart/form-data\"&gt;&gt; &#123;% csrf_token %&#125;&gt; &lt;input type=\"text\" placeholder=\"文章标题\"&gt;&gt; &lt;br&gt;&gt; &lt;input type=\"text\" placeholder=\"文章作者\"&gt;&gt; &lt;br&gt;&gt; &lt;input id=\"rich_content\" name=\"content\" value=\" \"&gt;&gt; &lt;br&gt;&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&gt; &lt;/form&gt;&gt; 修改插件配置 这里搭配了一个tinymce_setup.js文件，用来控制富文本编辑器所使用的插件等 全文配置如下 12345678910111213141516171819202122232425262728293031323334353637&gt; tinymce.init(&#123;&gt; // 选择id为content的标签作为编辑器&gt; selector: '#rich_content',&gt; // 方向从左到右&gt; directionality:'ltr',&gt; // 语言选择中文&gt; language:'zh_CN',&gt; // 高度为400 宽度为一半&gt; height:300,&gt; width: '50%',&gt; // 工具栏上面的补丁按钮&gt; plugins: [&gt; 'advlist autolink link image lists charmap print preview hr anchor pagebreak spellchecker',&gt; 'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking',&gt; 'save table contextmenu directionality template paste textcolor',&gt; 'codesample imageupload',&gt; ],&gt; // 工具栏的补丁按钮&gt; toolbar: 'insertfile undo redo | \\&gt; styleselect | \\&gt; bold italic | \\&gt; alignleft aligncenter alignright alignjustify | \\&gt; bullist numlist outdent indent | \\&gt; link image | \\&gt; print preview media fullpage | \\&gt; forecolor backcolor emoticons |\\&gt; codesample fontsizeselect fullscreen |\\&gt; imageupload',&gt; // 字体大小&gt; fontsize_formats: '10pt 12pt 14pt 18pt 24pt 36pt',&gt; // 按tab不换行&gt; nonbreaking_force_tab: true,&gt; imageupload_url: \"/upload_img/\",&gt; // 上传后图片保存为绝对路径&gt; relative_urls : false,&gt; &#125;);&gt; 注释已经很清晰 要注意的是imageupload_url配置用来确定当前图片上传所对应的视图路由 上传视图配置 接下来编写富文本编辑器的上传图片路由函数及对应的路由配置 路由映射tinymce_setup.js与中的imageupload_url配置路由相同 这里还要注意，由于此时tinymce的上传图片表单并不是和本身所容纳的form表单一起上传，所以并不会具备csrf_token值，需要我们将上传图片的函数额外进行装饰器装饰，取消csrf_token验证 123456789101112131415161718192021222324&gt; #views.py&gt; from django.views.decorators.csrf import csrf_exempt&gt; def md5(str_):&gt; import time&gt; m = hashlib.md5()&gt; m.update(str(time.time()).encode())&gt; filename = m.hexdigest()&gt; return filename + '.' + str_.split('.')[-1]&gt; &gt; @csrf_exempt&gt; def upload_img(request):&gt; if request.method == 'POST':&gt; img = request.FILES.get('file')&gt; if img:&gt; file_name_md5 = md5(img.name)&gt; with open(os.path.join(UPLOAD_ROOT,file_name_md5), 'wb') as fp:&gt; for buf in img.chunks():&gt; fp.write(buf)&gt; # 迭代读取文件并写入到本地&gt; response = &#123;&#125;&gt; response['path'] = '/upload/' + file_name_md5&gt; response['error'] = False&gt; return HttpResponse(json.dumps(response))&gt; 视图函数还是老样子去接收上传文件并保存即可 这里还使用了md5的方式进行文件名保存，避免重名文件上传互相覆盖 路由配置 123&gt; #urls.py&gt; path('upload_img/',views.upload_img),&gt; 表单接收视图 以上的视图函数只能处理上传图片的内容接收 我们的模板页面中还有作者及标题两样表单内容会被POST提交到后台 并且要主要的是，富文本编辑器里除了图片的内容，还有文字等其他内容，这里也需要我们保存下来 这里还需要一个视图函数去接管处理 1234567891011121314&gt; def index(request):&gt; if request.method == 'GET':&gt; return render(request, 'index.html')&gt; if request.method == 'POST':&gt; title = request.POST.get('title')&gt; author = request.POST.get('author')&gt; content = request.POST.get('content')&gt; models.Article.objects.create(&gt; title = title,&gt; author = author,&gt; content = content,&gt; )&gt; return redirect('/show/')&gt; 表单路由 123&gt; #urls.py&gt; path('',views.index),&gt; 这里上传之后，保存在后台的content数据是这个样子 12&gt; &lt;p&gt;&lt;img src=\"/upload/ec8f8c9a56ed32464a6727741fd58d8d.png\" /&gt;&lt;/p&gt;&lt;p&gt;今天&lt;em&gt;一切&lt;/em&gt;都是&lt;strong&gt;美丽&lt;/strong&gt;的，哈哈哈&lt;/p&gt;&gt; 图片访问路由 当有了上传图片的视图函数及所有内容的接收视图函数 这里还有一个特殊的问题，现在如果在富文本编辑器中选择上传图片，你会发现图片已经在选择时就已经存储到了后台upload文件夹下，这也是为什么我们的图片上传视图函数要单独编写，并且还需要取消csrf_token的验证的原因 除了这个问题你还会发现，在富文本编辑器中，上传的图片是看不到的，是一个坏掉的图片； 使用F12开发者工具你可以看到，这里的图片展示为一个img标签，而标签的src属性内容正是通过上传视图函数返回的response中的path值 想让这个path值在访问时，能获取到实际的图片效果，需要我们在路由文件中继续配置，配置专门的upload/xxxx.jpg的图片路由访问，让图片真正展示出来 1234&gt; #urls.py&gt; from django.views.static import serve&gt; re_path('^upload/(?P&lt;path&gt;.*)/$',serve,&#123;'document_root':UPLOAD_ROOT&#125;),&gt; 上传后图片的访问路径是/upload/，那么这里的路由也是upload/，之后通过静态文件映射函数serve查找upload文件夹下的同路径同名图片资源 当有了这条路由配置之后，再次再富文本编辑器中加入图片，你就会发现图片出现啦 上传并展示 最后，我们将测试上传图片及文字 并且上传成功之后，重定向到show视图函数 这个视图函数用来提取当前最新的上传数据并返回到模板页面 123456&gt; #views.py&gt; def show(request):&gt; if request.method == 'GET':&gt; article = models.Article.objects.all().last()&gt; return render(request,'show.html',locals())&gt; 展示的模板页面 12345678910111213141516&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;meta charset=\"utf-8\"&gt;&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&gt; &lt;title&gt;展示文章&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &#123;% if article %&#125;&gt; &lt;h3&gt;&#123;&#123; article.title &#125;&#125;&lt;/h3&gt;&gt; &lt;h4&gt;&#123;&#123; article.author &#125;&#125;&lt;/h4&gt;&gt; &lt;div&gt;&#123;&#123; article.content|safe &#125;&#125;&lt;/div&gt;&gt; &#123;% endif %&#125;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; 其实本身富文本编辑器上传的文本内容就已经在一个p标签中，所以这里没有用段落标签 另外由于保存在数据库的文本为html格式，而后台传递来的模板变量django出于安全考虑会自动进行转义，直接观看到的效果不会html样式，只是一些普通字符串； 这里可以使用safe过滤器将内容认定为安全，展示为原始的html效果，其实还不错 总结 富文本编辑器其实就是将用户输入的内容变为html代码 这里的图文混排，只是在图片加入时，单独将图片上传保存，并且回调获取到上传的路径 之后只需要服务端后台配置好相关的上传图片访问路由配置即可","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django缓存系统","slug":"Django缓存系统","date":"2019-10-21T01:58:40.498Z","updated":"2019-10-21T01:59:26.327Z","comments":true,"path":"2019/10/21/Django缓存系统/","link":"","permalink":"http://laxe.top/2019/10/21/Django缓存系统/","excerpt":"缓存 Django 是动态Web后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个Web系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。 相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多","text":"缓存 Django 是动态Web后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个Web系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。 相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多 浏览器第一次请求时，cache会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置response头部 当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回response给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给response给客户端 Cache-Control 12&gt; HTTP`协议头`Cache-Control`，`Cache-Control`与`Expires`的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过`Cache-Control`的选择更多，设置更细致，如果同时设置的话，其优先级高于`Expires&gt; 在python中使用memcached需要我们额外安装memcached作为memcache客户端的支持 1pip3 install python-memcached -i https://pypi.tuna.tsinghua.edu.cn/simple Cache设置memcached 安装memcached 12apt-get install memcached # debianyum install memcached # centos 配置文件：/etc/memcached.conf 配置文件中有两个可能需要修改的参数 12-m 64 #memcached所能使用的内存大小-l 127.0.0.1 #监听的IP地址 开启|关闭memcached服务 12systemctl start memcached # 开启systemctl stop memcached # 关闭 查看服务状态 1systemctl status memcached settings配置 使用memcached缓存，首先需要在项目的settings文件下进行配置 12345678CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', # 指定缓存使用的引擎 'LOCATION':'172.16.19.26:11211', # 指定缓存服务器地址，常为本机地址 &#125;&#125; 视图缓存 可以只为某些视图函数进行缓存 使用django.views.decorators.cache下的装饰器cache_page进行视图函数装饰即可 模型类的表代码 12class People(models.Model): name = models.CharField(max_length=20,verbose_name='名字') 视图函数代码 1234567from django.views.decorators.cache import cache_page@cache_page(10) # 缓存10秒def index(request): print('视图函数被调用') ss = models.People.objects.all() return render(request, 'index.html', locals()) 模板页面代码 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;展示数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% for s in ss %&#125; &lt;li&gt;&#123;&#123; s.name &#125;&#125; &lt;/li&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 在第一次刷新浏览器之后， 立即在数据库中添加一个新的数据对象 接着继续刷新浏览器，前端页面将会读取缓存中的结果，而不会显示刚才添加的用户 除了在视图函数上使用装饰器进行缓存设置，还可以在路由匹配部分使用相同装饰器函数进行设置 全站缓存 将整站所有视图设置缓存，需要在配置文件的中间件设置首尾部分添加如下内容 12345678MIDDLEWARE = [ 'django.middleware.cache.UpdateCacheMiddleware', # 首部要添加的中间件 # 将response缓存起来 'django.middleware.security.SecurityMiddleware', ... 'django.middleware.cache.FetchFromCacheMiddleware',# 尾部要添加的中间件 # 将缓存的response取出来] 以及搭配设置当前全站缓存有效时间的全局变量 1CACHE_MIDDLEWARE_SECONDS = 10 # 每页页面缓存的秒数，默认为600 局部缓存 局部缓存主要为在模板页面，选择某个区域进行缓存，当用户再次访问相同页面时，如设置缓存未过期，则渲染时局部缓存不会重新生成 12345&#123;% load cache %&#125; 局部缓存首先需要加载cache标签 &#123;% cache sec key %&#125;&#123;% endcache %&#125; 以时间模板变量为例，做一个简单的测试，后台视图函数每次在访问时，返回当前时间 12import time now = time.strftime('%H:%M:%S', time.localtime()) 模板页面在使用时的代码 123456&#123;% load cache %&#125;&lt;p&gt;这里是未缓存的时间:&#123;&#123; now &#125;&#125;&lt;/p&gt;&#123;% cache 10 time %&#125;&lt;p&gt;这里是缓存的时间:&#123;&#123; now &#125;&#125;&lt;/p&gt;&#123;% endcache %&#125; 手动缓存 除了以上应用于各个业务中的缓存方式，还可以使用django所提供的cache接口进行缓存设置以及获取 设置缓存 1234from django.core.cache import cache#存储缓存数据cache.set('cache_key',data,60*15)#cache_key为存储在缓存中的唯一值，data为存储的数据，60*15为缓存有效时间 获取缓存 123#获取缓存数据cache.get('cache_key','获取不到的默认值')#cache_key为储存缓存数据的唯一值 避免key值重复导致更新缓存，可以使用cache.add函数，基本用法与set相同 123status = cache.add('add_key', 'New value')# 当指定key值的缓存存在，add方法不会尝试更新缓存# 返回值status为True时，代表存储成功，False代表存储失败 清除缓存，通过cache.delete方法，该方法接收一个缓存key值 1cache.delete('cache_key') 清空缓存，通过cache.clear方法，直接从缓存中清除所有 1cache.clear() 注意 memcached不允许使用超过250个字符或包含空格或控制字符的缓存键值 使用这样的键值将会导致异常","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Django中的Admin组件","slug":"Django中的Admin组件","date":"2019-10-21T01:54:12.526Z","updated":"2019-10-21T01:57:16.741Z","comments":true,"path":"2019/10/21/Django中的Admin组件/","link":"","permalink":"http://laxe.top/2019/10/21/Django中的Admin组件/","excerpt":"管理员 Django-admin界面是框架为我们提供的Web-APP的管理工具 在之前的练习中，我们已经多次使用它进行APP中表的DML语句操作 接下来，我们可以继续来学习，如何将Admin界面进行优化扩展，更加方便我们后台管理","text":"管理员 Django-admin界面是框架为我们提供的Web-APP的管理工具 在之前的练习中，我们已经多次使用它进行APP中表的DML语句操作 接下来，我们可以继续来学习，如何将Admin界面进行优化扩展，更加方便我们后台管理 管理员注册设置 在admin界面中，我们可以通过继承admin.ModelAdmin类进行自定义admin类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样 123456789＃models.py 类 用户（models.Model）： 名称= models.CharField（max_length = 20） age = models.IntegerField （）def __str__ （self）：返回 self.name ＃admin.py 类 UserAdmin （admin.ModelAdmin）： 字段=（'name'，'age'）＃控制管理界面模型类展示位置 admin.site.register（User，UserAdmin） 常用的 list_display：在admin控制台数据列表页面展示更多的细分 list_display_links：用于设置当前列表中由list_display所设置的附加部分可以点击 fieldsets：将admin界面下的表单输入栏进行分块 12345类 UserAdmin （admin.ModelAdmin） ： 字段=（ '姓名'， '年龄'） 字段集=（ （ '第一个区域'， &#123; '字段'：（ '姓名'） &#125; ） （ '第二个区域'， &#123; 'fields'：（ 'age'，） &#125; ） ） search_fields：在admin数据展示页，设置一个搜索框，设置的分段是可查找的属性 1search_fields =（'name'，） list_filter：以什么分解进行过滤，在admin页面上方展示 ordering：数据列表可以通过某些细分进行排序 利用现有用户系统 12&gt; from django.contrib.auth.models import User&gt; 用户细分 username 必选。少于等于30个字符。用户名可以包含字母，数字，_， ，@，。+状语从句：-字符 first_name 任选。等于等于30个字符 last_name 可选。可以输入30个字符 email 任选。邮箱地址 password 必选。密码的哈希及元数据。（Django不保存原始密码）。原始密码可以无限长而且可以包含任意字符 is_staff 布尔值。指示用户是否可以访问Admin站点 is_active 布尔值。用户的账号是否激活。长使用这个标志为False来代替删除账号 is_superuser 布尔值。指定这个用户拥有所有的权限而不需要给他们分配明确的权限 last_login 用户最后一次登录的时间。如果这个用户没有登录过，这个细分将会是null 之前版本默认设置为的当前的datetime date_joined 帐户创建的时间。当账号创建时，替代设置为当前的datetime 用户实例方法 get_username() 获取到当前的用户的用户名属性 is_authenticated() 检查用户是否已通过认证 is_anonymous() 检查用户是否未通过认证 set_password(password) 设置保存用户的密码，和会负责密码的哈希加密工作 通常修改密码之后还需要调用save()方法进行数据更新 用户表方法 create_user(username, email=None, password=None, **extra_fields) django的用户创建需要使用User表管理器中的create_user函数进行 该函数可以创建并保存一个用户 create_superuser(username, email, password, **extra_fields) 与上一个创建用户函数功能相同，但是额外会设置用户的is_staff及is_superuser属性为True 创建一个admin后台超级用户 其他方法 authenticate(username,password) 验证是否为合法用户，如果用户存在合法则返回一个用户对象 logout() 清除当前浏览器下用户session login(request,user) 登录并保存当前用户session 接受参数为HttpRequest请求及一个User用户对象 参数user必须为使用authenticate验证过后的用户对象 用户登录 登陆所需表单类 123456789101112131415＃forms.py 从 django的进口形式从 django.contrib.auth.models 导入用户进口重新类 LoginForm的（forms.Form） ： 用户名= forms.CharField（标记= “用户名”，需要= 真，） 密码=形式。 CharField（ widget = forms.PasswordInput（）， label = '密码'， required = True， ）def clean_username （self）： username = self.cleaned_data.get（“ username”）.strip（）try ： User.objects.get（用户名=用户名），但 User.DoesNotExist 除外：引发 Forms.ValidationError（“用户名％s不存在”％用户名）else：返回用户名 登录所需模板页面 12345678910111213141516171819202122232425&lt;！DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/ title&gt; &lt;/ head&gt; &lt;body&gt; &lt;form action ='/ login /'method =“ POST”&gt; &#123;％csrf_token％&#125; &#123;&#123;错误&#125; &#125; &#123;％表示形式为％的字段&#125; &lt;label&gt; &#123;％表示field.errors％&#125; &lt;ul&gt; &#123;％表示error。％s错误&#125; &lt;li&gt; &#123;&#123;error&#125;&#125; &lt;/ li&gt; &#123;％endfor％&#125; &lt;/ ul&gt; &#123;％endif％&#125; &lt;/ label&gt; &lt;p&gt; &#123;&#123;field.label&#125;&#125;：&#123;&#123;field&#125;&#125; &lt;/ p&gt; &#123;％endfor％&#125; &lt;input type =“ submit” value =“登录” &gt; &lt;/ form&gt; &lt;/ body&gt; &lt;/ html&gt; 登陆主要视图逻辑 12345678910111213＃views.py 从 django.contrib.auth 进口身份验证，注销作为 auth_logout，登录作为 auth_login DEF 登录（请求）：如果 request.method == 'GET' ： 形式=用户窗体（）返回渲染（请求，“的login.html “，&#123; 'form'：form&#125;） form = userForm（request.POST） 用户名= form.data [ 'username' ] 密码= form.data [ 'password' ] user = authenticate（username = username，password = password）＃验证当前账号密码是否符合合法如果用户 和 user.is_active： auth_login（请求，用户）返回 redirect（'/'）else：返回 render（request，“ login.html”，&#123; 'form'：form，'errors'：'用户名或密码错误' &#125; ） 在用户登录成功之后，将会重新进入主页，主页展示当前登录用户 登录用户可以直接在request.user属性中获取到，主页的模板内容如下 主页模板 123&lt;！DOCTYPE html&gt; &lt; html &gt; &lt; head &gt; &lt; title &gt;主页&lt;/ title &gt; &lt;/ head &gt; &lt; body &gt; 欢迎你：&#123;&#123;user&#125;&#125; &lt;/ body &gt; &lt;/ html &gt; 主页视图函数可以通过装饰器@login_required或判断is_authenticated状态来查看用户是否登录 只有登录用户可以访问该站点 使用当装饰器@login_required时，在需要settings下设置LOGIN_URL = &#39;/login/&#39; 引入属性设置为登录路由 首页视图函数 123从 django.contrib.auth.decorators中导入 login_required ＃@ login_required def 索引（请求）：如果 request.user.is_authenticated（）：返回 render（请求，“ index.html”）否则：返回重定向（'/ login /'） 注册功能 注册所需表单 123456789101112131415161718192021222324＃forms.py 类 RegisterForm （forms.Form）： 用户名= form.CharField（label = “用户名”， max_length = 30， required = True， error_messages = &#123; 'max_length'：'账号长度最长为30' &#125;， ） password = form.CharField（label = “密码”， min_length = 6，max_length = 30， widget = forms.PasswordInput（）， required = True， error_messages = &#123; 'min_length'：'密码长度最短为6' &#125;， ） check_password = forms.CharField（label = “重复密码”， min_length = 6，max_length = 30， widget = forms.PasswordInput（）， required = True， error_messages = &#123; 'min_length'：'密码长度最短为6' &#125;， ）def clean_check_password （self）： 密码= self.cleaned_data.get（'password'） check_password = self.cleaned_data.get（'check_password'）如果 password！= check_password 和 password 和 check_password：提高 ValidationError（“重复输入密码错误”）def clean_username （self）： username = self.cleaned_data.get（'username'）if username [：1 ] == '_'：提出表格。ValidationError（“用户名不能以下划线打头“）尝试： User.objects.get（username = username）除外 User.DoesNotExist：返回用户名引发表单。ValidationError（”用户名已存在“） 表单中，将对用户两次输入的密码进行校验和判断是否为空，而且分开下划线作为用户名的开头字符 注册主要视图函数逻辑 1234567891011121314＃views.py def 寄存器（请求）：if request.method == 'POST'： form = RegisterForm（request.POST）if form.is_valid（）： username = form.cleaned_data [ 'username' ] 密码= form.cleaned_data [ 'password' ] User.objects.create_user（username = username，password = password） user = authenticate（username = username，password = password） auth_login（request，user）return redirect（'/'）else： form = RegisterForm（ ）返回 渲染（请求，“ register.html”，&#123; 'form'：form&#125;） 通过表单验证，并获取到对应的用户账号密码，创建成功之后，验证并登录，并重定向到首页 主页模板页面 12345678910111213141516171819202122232425262728&lt;！DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;注册&lt;/ title&gt; &lt;/ head&gt; &lt;body&gt; &#123;％如果request.user.is_authenticated％&#125; &lt;p&gt;您已登录：&lt;/ p&gt; &#123;&#123;用户&#125;&#125; &#123;％else％&#125; &lt;form action ='/ register /'method =“ POST”&gt; &#123;％csrf_token％&#125; &#123;％表示形式为％的字段&#125; &lt;label&gt; &#123;％if field.errors％&#125; &lt;ul&gt; &#123; ％for field.errors％&#125; &lt;li&gt; &#123;&#123;error&#125;&#125; &lt;/ li&gt; &#123;％endfor％&#125; &lt;/ ul&gt; &#123;％endif％&#125; &lt;/ label&gt; &lt;p&gt; &#123;&#123;field.label&#125;&#125;： &#123;&#123;field&#125;&#125; &lt;/ p&gt; &#123;％endfor％&#125; &lt;input type =“ submit”value =“注册”&gt; &lt;/ form&gt; &#123;％endif％&#125; &lt;/ body&gt; &lt;/ html&gt; 当用户已经登录时，显示当前登录用户，反之则展示表单，以供用户填写 重载admin用户系统 django自带的admin模块下的用户系统主要负责用户帐户，组，权限和基于cookie的会话等业务 认证系统由以下部分组成： 用户：包含用户数据细分，是实现业务功能逻辑的基础 权限：控制用户进入否可以执行某项任务的二进制（是/否）标志。 组：一种为多个用户加上标签和权限的常用方式。 消息：一种为指定用户生成简单消息嵌入的方式 默认预设 username 必选项，小于等于30个字符；只能是字母数字（字母，数字和下划线） first_name 可选项，等于等于30个字符 last_name 可选项，等于等于30个字符 email 可选项。电子邮件地址 password 必选，密码（哈希值，元数据） Django不储存原始密码 原始密码可以是任意长度的，包含任何字符 密码由哈希类型，盐值和哈希值组成，用美元符合分隔 is_staff 布尔值，指明这个用户是否可以进入管理站点的权限 is_active 布尔值，指明这个用户帐户是否是活动的 我们建议把这个标记设置为False来代替删除用户帐户，这样就不会影响指向用户的外键 这个属性不控制用户是否可以登录。登录验证时不会核查is_active标志。 因此，如果在登录时需要检查is_active标志，需要你在自己的登录视图中实现 用于login()视图的AuthenticationForm会执行这个检查，判断用户是否是活跃账户 is_superuser 布尔值，规范用户拥有所有权限（包括显式赋予和非显式赋予的） last_login 预期情况下设置为用户最后一次登录的日期时间 date_joined 预期情况下设置为用户帐户创建的日期时间 默认方法 在项目中，我们将使用电子邮件作为用户的用户名，那么可以在自带用户表中写明 12&gt; USERNAME_FIELD = 'email'&gt; 该属性设置当前表的登陆细分 描述我们自定义用户模型上作的唯一标识符分割名称的字符串，分段必须是唯一的，在定义中设置unique=True 12&gt; REQUIRED_FIELDS = ['username']&gt; 设置当前该基线为必填细分 is_authenticated() 判断用户是否已通过身份验证的方法，不意味任何权限，而且不检查用户的活动状态 get_username() 返回由USERNAME_FIELD制定的细分的值 get_full_name（） 返回first_name加上last_name 中间加上一个空格，由于我们重新设置了表分区，那么这个变量函数需要我们重新给定返回值 get_short_name() 一个短的且非正式用户的标识符，返回first_name 当你的项目重写该静态或直接去掉了first_name，所以我们必须重新给定这个函数的返回值 set_password() 将用户的密码设置为给定的字符串 has_perm(perm, obj=None) 用户是否具有某个权限，如果给定obj，则需要根据特定对象实例检查权限 has_module_perms(app_label) 如果用户有权访问给定应用中的模型，则返回True 这里我们这两个分区都设置为True，可以让用户访问任一APP is_staff()@property 如果用户允许访问管理网站，则返回True 这里我们返回is_admin的随机属性即可 关于细分属性，如果需要进行高度扩展 可以使用继承AbstractBaseUser这个类 这个类中只含有password， ，last_login以及is_active三个字段属性 重载管理器 由于已经覆盖了替代的admin用户表，现在需要将其对应的管理器函数进行编写 编写时主要关注一下两个父类函数的重写 1234567891011121314151617181920212223create_user（username_field，password_filed = None，** other_fields） normalize_email（）将邮件地址规范化的类方法 user.save（using = self._db）create_superuser（用户名，电子邮件，密码）＃用户创建，is_admin设置为真 user.save（using = self._db） 从 django.contrib.auth.models 导入 BaseUserManager 类 MyUserManager （BaseUserManager） ：高清create_user （个体经营，用户名，电子邮件，密码=无）：如果没有电子邮件：提高 ValueError异常（“用户必须拥有一个电子邮件地址”），如果没有用户名：引发 ValueError（'用户必须具有用户名'）＃判断邮件和用户名是否具有 now = timezone.now（）＃获取当前django的时间 user = self.model（ 用户名=用户名， email = self.normalize_email（email） ， date_joined = now， last_login = now， ） user.set_password（password） user.save（using = self._db）返回用户def create_superuser （self，username，email，password）： user = self.create_user（username， email， password = password， ） user.is_admin = True user.save（using = self._db）返回用户 重新定义新用户表的管理器之后，想要生效，还需要在对应的模型类表中覆盖objects属性 objects = MyUserManager() 重载表 下面是一个真实的重载自带用户表的模型类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172从 django.contrib.auth.models 导入 AbstractBaseUser 类 成员（AbstractBaseUser）：#AbstractBaseUser中只包含3个字段：password，last_login和is_active。 email = models.EmailField（verbose_name = '邮箱'，max_length = 255，unique = True，） 用户名= models.CharField（verbose_name = “用户名”，max_length = 16，unique = True） weibo_id = models.CharField（verbose_name = “新浪微博”，max_length = 30，空白= True） 博客= models.CharField（verbose_name = “个人网站” ，max_length = 200，blank = True） 位置=模型。CharField（verbose_name = “城市”，max_length = 10，blank = True） profile =模型。CharField（verbose_name = “个人简介”，max_length = 140，blank = True） 头像= models.CharField（verbose_name = “头像”，max_length = 128，blank = True） au = models.IntegerField（verbose_name = “用户活跃度”，默认= 0） last_ip = models.IPAddressField（verbose_name = “上次访问IP”，默认= “ 0.0.0。0“） email_verified = models.BooleanField（verbose_name = “邮箱是否验证”，默认= False） date_joined = models.DateTimeField（verbose_name = “用户注册时间”，default = timezone.now） topic_num = models.IntegerField（verbose_name = “帖子数”，默认= 0） comment_num = models.IntegerField（verbose_name = “评论数”，default = 0） is_active = models.BooleanField（default = True） is_admin = models.BooleanField（默认= False） objects = MyUserManager（）#objects就是我们之前一直使用的管理器＃管理器用来维护我们的增删改查 USERNAME_FIELD = '电子邮件' REQUIRED_FIELDS = [ '用户名' ] 高清 __str__ （个体经营）：返回 self.username＃标签中的数据实例高清is_email_verified （个体经营）：返回 self.email_verified＃我们可以在模板中，通过实例出来的对象数据进行这个函数的调取，获取他是否验证过def get_weibo （个体）：返回 self.weibo_id def get_username （self）：返回 self.username＃方法的圆括号在模板标签中必需省略！！def get_username （self）：返回 self.username＃方法的圆括号在模板标签中必需省略！！ def get_full_name （self）：＃用户通过其电子邮件地址return self进行标识。email # get_full_name本来是获取名字和姓氏的＃但由于我们重新设置了表结构，所以此函数必须自定义＃方法的圆括号在templates标签中必需省略！！ def get_short_name （self）：＃用户通过其电子邮件地址返回 self.username进行标识 def has_perm （self，perm，obj = None）：“用户是否具有特定权限？” 返回True def has_module_perms （自己，app_label）：“用户是否有权查看应用程序`app_label`？” 返回True DEF calculate_au （个体）：“”， “ 计算活跃度 公式的：主题* 5 +注释* 1 ”“” self.au = self.topic_num * 5 + self.comment_num * 1 返回 self.au @ property＃类中函数可以直接做为属性使用def is_staff （个体）：“用户是工作人员吗？” ＃最简单的答案：所有管理员都是员工返回 self.is_admin 重载Admin表单 由于修改了默认的django表结构，此时在admin界面修改密码或添加用户数据已经不能再按照之前的表单系统啦 需要在app的admin.py中重写UserCreationForm和UserChangeForm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768＃用户创建表单从 Django的进口形式从 django.contrib中输入管理员从 django.contrib.auth.admin 进口 UserAdmin 从 django.contrib.auth.forms 导入 ReadOnlyPasswordHashField 从 people.models 导入会员，跟随class UserCreationForm （forms.ModelForm）：“”“用于创建新用户的表单。包括所有必填 字段以及重复的密码。”“” password1 = form.CharField（label = '密码'，widget = forms.PasswordInput） password2 = Forms.CharField（label = '确认密码'，widget = forms.PasswordInput）类Meta： model =成员 字段=（ 'email'， 'username'） def clean_password2 （self）： password1 = self.cleaned_data.get（ “ password1”） password2 = self.cleaned_data.get（ “ password2”）如果 password1和 password2和 password1！= password2：提出 form.ValidationError（ “输入确认失败“） return password2＃在窗体中的clean__field函数会在is_valid（）函数验证时自动调用def save （self，commit = True）： user = super（UserCreationForm，self）.save（commit = False） user.set_password （self.cleaned_data [ “ password1” ]）#set_password将采用django的加密算法将密码设置到对应的模型实例中＃在内存中创建的好的对象只能通过commit = True才被真正执行到数据库上如果提交： user.save（）return用户 ＃密码更改时的展示表单类 UserChangeForm （forms.ModelForm）： 密码= ReadOnlyPasswordHashField（）类Meta： 模型=成员 字段=（'email'，'password'，'username'，'is_active'，'is_admin'，）def clean_password （self）：返回 self.initial [ “ password” ] ＃使用替代的保存函数即可 ＃真正的用户管理界面管理方式类 MyUserAdmin （UserAdmin）： 形式= UserChangeForm add_form = UserCreationForm list_display =（'id'，'email'，'username'，'email_verified'，'last_login'，'is_active'，'is_admin'，'last_ip'） list_display_links =（'id'，'email'，'用户名'） list_filter =（'email'，'email_verified'，） 字段集=（ （无，&#123; 'fields'：（（'username'，'email'，'date_joined'，'password'，'is_active'，'is_admin'，'avatar'）&#125;）， （'状态'，&#123; 'fields'：（' email_verified'，'last_ip'，'au'，'topic_num'，'comment_num'）&#125;）， （'社交网络'，&#123; 'fields'：（'weibo_id'，'blog'）&#125;）， ） add_fieldsets =（ （无，&#123; 'classes'：（'wide'，），#admin样式设置#Fieldsets使用wide样式将会有额外的水平间距。'fields'：（（'email'，'username'，'password1'，'password2'，'is_active'，'is_admin'）&#125; ） ）） search_fields =（'id'，'email'，'username'） ordering = （'id'，'email'，'email_verified' admin.site.register（成员，MyUserAdmin）admin.site.register（跟随者） 最终 还需要在settings.py文件下进行设置，覆盖最小的User模型 AUTH_USER_MODEL = &#39;people.Member&#39;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]},{"title":"Websocket","slug":"Websocket","date":"2019-10-21T01:39:19.954Z","updated":"2019-10-21T01:57:26.918Z","comments":true,"path":"2019/10/21/Websocket/","link":"","permalink":"http://laxe.top/2019/10/21/Websocket/","excerpt":"Websocket WebSocket实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。 传统的HTTP协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的Web应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题","text":"Websocket WebSocket实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。 传统的HTTP协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的Web应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。这种方法会导致过多不必要的请求，浪费流量和服务器资源。 Comet技术又可以分为长轮询和流技术；长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 WebSocket真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力 WebSocket的工作流程是这样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小了很多 Websocket在建立连接之前有一个Handshake（Opening Handshake）过程，在关闭连接前也有一个Handshake（Closing Handshake）过程，建立连接之后，双方即可双向通信 HTML的Websocket 初始化websocket 1var ws = new WebSocket(url, [protocol] ); 12&gt; url`：指定连接的`websocket&gt; protocol：可接受的子协议 响应事件 当ws套接字初始化成功之后，我们可以通过定义回调函数在某些事件触发时执行，以下是常见响应事件 当ws连接建立时触发 123ws.onopen = function()&#123; // 连接开启&#125; 当ws连接接收到数据时触发 123ws.onmessage = function(evt)&#123; // evt.data即是接收到的数据对象&#125; 当ws连接发生通信错误时触发 123ws.onerror = function()&#123; // 连接出错&#125; 当连接关闭时触发 123ws.onclose = function()&#123; // 连接关闭&#125; 初次之外，还可以通过一些方法函数进行数据的传输或连接的关闭 方法 通过ws连接发送数据 1ws.send(str) 关闭连接 1ws.close() 简单的示例12345678910111213141516171819var ws = new WebSocket('ws://127.0.0.1:3000')ws.onopen = function()&#123; console.log('连接建立')&#125;ws.onmessage = function(ev)&#123; console.log('server:',ev.data)&#125;ws.onerror = function()&#123; console.log('连接建立') ws.close()&#125;ws.onclose = function()&#123; console.log('连接关闭') ws.close()&#125; Django的Websocket dwebsocket是一个在django用来实现websocket服务端的三方模块，使用上手非常简单，安装方式如下 1pip install dwebsocket git地址 https://github.com/duanhongyi/dwebsocket 方法 在后台中，通过该三方模块可以让我们在django的视图中实现对于websocket的操作 首先是两个基本的装饰器，用来限定过滤websocket的连接 dwebsocket.accept_websocket 允许http与websocket连接 dwebsocket.require_websocke 只允许websocket连接 除去两种装饰器方法进行过滤判断，还可以通过在视图函数中的request进行websocket的判断 request.is_websocket 如果是个websocket请求返回True，如果是个普通的http请求返回False 可以用这个方法区分普通连接与websocket request.websocket 在一个websocket请求建立之后，这个请求将会有一个websocket属性，用来给客户端提供一个简单的api通讯，如果request.is_websocket()是False，这个属性将是None request.websocket.wait 接收客户端发来的一条消息；如果在收到消息或客户端关闭连接之前，它不会有任何返回，只会返回None request.websocket.read 如果从客户端接收到新消息，read函数返回这条消息；如果没有新消息，则返回None 这是一个替代wait的非阻塞读取数据的方法 request.websocket.count_messages() 返回消息队列数量 request.websocket.has_messages() 如果有新消息返回True，否则返回False request.websocket.send(message) 向客户端发送消息 requqest.websocket.__iter__ websocket迭代器 关于Django的Demo将会在下一章节结合paramiko以及xterm.js来进行一个webssh的实现","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://laxe.top/tags/Django/"}]}]}